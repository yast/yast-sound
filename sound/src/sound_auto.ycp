/**
 * File:
 *   sound_auto.ycp
 *
 * Package:
 *   Configuration of sound
 *
 * Summary:
 *   Client for autoinstallation
 *
 * Authors:
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * This is a client for autoinstallation. It takes its arguments,
 * goes through the configuration and return the setting.
 * Does not do any changes to the configuration.
 */

/**
 * @param first a map of x settings
 * @return boolean success of operation
 * @example map mm = $[ "FAIL_DELAY" : "77" ];
 * @example map ret = WFM::CallModule ("x_auto", [ mm ]);
 */

{
    textdomain "sound";

    y2milestone("----------------------------------------");
    y2milestone("Sound auto started");

    import "Sound";
    import "Mode";
    import "Summary";
    import "Wizard";
    import "PulseAudio";

    any ret = nil;
    string func = "";
    map param = $[];

    /* Check arguments */
    if (size(WFM::Args()) > 0 && is(WFM::Args(0), string)) {
	func = (string) WFM::Args(0);
	if(size(WFM::Args()) > 1 && is(WFM::Args(1), map))
	    param = (map) WFM::Args(1);
    }
    y2debug("func=%1", func);
    y2debug("param=%1", param);


    include "sound/routines.ycp";
    include "sound/volume.ycp";

    /**
     * During autoinstallation write, update the card's from control file
     * to match the detected cards from the current system
     */
    map UpdateCardsToTargetSystem (map settings) ``{

	list<map> save_info	= settings["modules_conf"]:[];

	Sound::DetectHardware();

	save_info = maplist (map saved_card, save_info, ``{
	    foreach (map e, Sound::detected_cards, ``{
		map mod = get_module (e);
		if (saved_card["module"]:"" == mod["name"]:"" &&
		    e["unique_key"]:"" != "")
		{
		    saved_card["unique_key"]    = e["unique_key"]:"";
		    saved_card["model"]		= get_card_label (e);
		}
	    });
	    return saved_card;
	});
	// ------------------------------------------------
	// now configure cards not included in control file

	y2milestone("configure_detected: %1", settings["configure_detected"]:false);

	if (settings["configure_detected"]:false)
	{
	    // Now update Sound data, so the configured cards can be recognized
	    // Import is not used, because it would remove detected cards
	    Sound::modules_conf		= eval (save_info);
	    Sound::volume_settings	= eval (Sound::ImportVolumeSettings(settings["volume_settings"]:[]));

	    Sound::UpdateUnconfiguredCards ();
	    foreach (map card, Sound::unconfigured_cards, ``{
		Sound::card_id	= size (save_info);
		card		= add_common_options (card, Sound::card_id);
		card		= add_alias (card, Sound::card_id);
		map res		=
		    sound_volume (card, Sound::card_id, true, true, save_info);
		if (res["ui"]:`back == `next)
		{
		    save_info	= add (save_info, card);
		    y2milestone ("Added sound card '%1'", card["model"]:"");
		}
	    });
	    settings["volume_settings"]	= Sound::ExportVolumeSettings(Sound::volume_settings);
	}
	settings["modules_conf"]	= eval (save_info);
	return settings;
    }

	/* Create a  summary*/
	if(func == "Import") {
		// detect the cards on the system, so we could write them
		// correctly:
		param = UpdateCardsToTargetSystem (param);
		ret = Sound::Import(param) && PulseAudio::Import(param);
	}
	/* Create a  summary*/
	else if(func == "Summary") {
		ret = Sound::Summary() + PulseAudio::Summary();
		y2milestone("Sound card configuration summary: %1", ret);
	}
	else if (func == "GetModified") {
		ret = Sound::GetModified();
	}
	else if (func == "SetModified") {
		Sound::SetModified();
		ret = true;
	}
	/* Reset configuration */
	else if (func == "Reset") {
		Sound::Import($[]);
		PulseAudio::Reset();
		ret = $[];
	}
	/* Change configuration (run AutoSequence) TODO */
	else if (func == "Change") {
		// initialize to empty lists
		Sound::detected_cards = [];
		Sound::unconfigured_cards = [];

		ret = WFM::CallFunction("sound", [] );
	}
	/* Return required package list */
	else if (func == "Packages") {
		list<string> packages_to_install = [];

		list<string> reqmodules = Sound::RequiredKernelModules();
		foreach(string driver, reqmodules,
		    {
			list<string> req_packages = Sound::RequiredPackagesToInstall(driver);
			packages_to_install = (list<string>)union(packages_to_install, req_packages);
		    }
		);

		y2milestone("Collected packages to install: %1", packages_to_install);

		ret = $[ "install" : packages_to_install ];
	}
	/* Return actual state */
	else if (func == "Export") {
		ret = Sound::Export();
		// add PulseAudio config if it's defined
		if (PulseAudio::Enabled() != nil)
		{
		    ret = union((map)ret, PulseAudio::Export());
		}
	}
	else if (func == "Read") {
		PulseAudio::Read();
		ret = Sound::Read (false);
	}
	/* Write given settings */
	else if (func == "Write") {
		import "Progress";
		boolean progress_orig = Progress::set(false);
		map settings = Sound::Export();
		Sound::write_only = true;
		ret = WFM::CallFunction ("sound_write", [ settings ]);
		Progress::set(progress_orig);
		return ret;
	}
	/* Unknown function */
	else {
		y2error("Unknown function: %1", func);
		ret = false;
	}

	y2milestone("ret=%1", ret);
	y2milestone("Sound auto finished");
	y2milestone("----------------------------------------");

	return ret;

	/* EOF */
}
