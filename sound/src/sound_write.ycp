/**
 * File:
 *   sound_write.ycp
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   Provides saving /etc/modules.conf and volume.
 *
 * Authors:
 *   Dan Vesely <dan@suse.cz>
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 *
 * Parameters are given in a map with keys:
 *         "modules_conf" ... save info- list of configured cards:
 *	   [
 *		$[
 *		    "model"	: "sb live!",
 *		    "alias"	: "snd-card-0",
 *		    "options"	: $["snd_id":"0" ...],
 *		    "module"	: "snd-emu10k1",
 *		    "unique_key": "abcd.efghijklmn"
 *                  "bus"       : "pci",
 *                  "bus_id"    : "0000:00:07.0"
 *		],
 *              $[
 *                  "model"     : "avi onboard!",
 *                  "alias"     : "snd-card-1",
 *                  "options"   : $["snd_id":"1" ...],
 *                  "module"    : "snd-asf",
 *                  "unique_key": "abcd.abcdefghij"
 *                  "bus"       : "pci",
 *                  "bus_id"    : "0000:00:03.1"
 *              ]
 *         ]
 *
 *	   "rc_vars" ... sysconfig values
 *	   $[
 *		"LOAD_SEQUENCER" : "yes"
 *         ]
 *
 *	   "vol_settings" ... volume setting (usefull only for autoconfig)
 *	   [
 *		[  // card #1
 *		    ["PCM", 32, false], ["Master", 100, true] ...
 *	        ],
 *		[  // card #2
 *		],
 *		...
 *
 *	   ]
 *
 * Steps:
 *        1. save '/etc/modules.conf'
 *        2. save '/etc/rc.config'
 *        3. save volume
 *        4. call function to provide some additional work
 *
 * Return boolean true on success, false if failed
 */
{
    textdomain "sound";


    include "sound/write_routines.ycp";

    import "Progress";
    import "Wizard";
    import "Service";
    import "Package";
    import "Mode";
    import "Report";
    import "Directory";

    import "Sound";
    import "Joystick";

    const string joy_cmd = Directory::bindir + "/joystickdrivers";
    const string alsa_cmd = Directory::bindir + "/alsadrivers";

    define void logmixer(string when) {
	// log mixer settings
	y2milestone("Mixer (%1): %2", when, SCR::Execute(.target.bash_output, "/usr/bin/amixer"));
	y2milestone("volume_settings: %1", Sound::volume_settings);
	y2milestone("asound size: %1", SCR::Read(.target.size, Sound::asound_state()));
    }

    define boolean install_packages(list<string> modules)
    {
	list<string> packages_to_install = [];

	foreach(string driver, modules,
	    {
		list<string> req_packages = Sound::RequiredPackagesToInstall(driver);
		packages_to_install = (list<string>)union(packages_to_install, req_packages);
	    }
	);

	y2milestone("Collected packages to install: %1", packages_to_install);

	if (size(packages_to_install) > 0)
	{
	    list<string> not_available = [];

	    foreach(string pkg, packages_to_install,
		{
		    boolean avail = Package::Available(pkg);

		    if (!avail)
		    {
			not_available = add(not_available, pkg);
		    }
		}
	    );

	    if (size(not_available) > 0)
	    {
		Report::Error(sformat(_("These required packages are not available: %1
Some sound devices may not work or some features may not be supported.

Enable or add an additional software repository containing the packages.
"), mergestring(not_available, ", ")));
		return false;
	    }

	    if (Sound::ConfirmPackages())
	    {
		return Package::InstallAll(packages_to_install);
	    }
	    else
	    {
		// do not ask the user, install the packages immediately
		return Package::DoInstall(packages_to_install);
	    }
	}

	return true;
    }

    // ==== MAIN ====

    map settings	= (map) WFM::Args(0);
    map rc_values	= settings["rc_vars"]:$[];
    list save_info	= settings["modules_conf"]:[];
    list vol_settings	= settings["volume_settings"]:[];

    // do nothing when proposal is empty
    // (Sound::installation is set to true in proposal mode)
    if (Sound::installation && size(save_info) == 0)
    {
	y2debug("empty proposal. exiting.");
	return true;
    }

    boolean install = !Sound::AllRequiredPackagesInstalled();

    list<string> stones = [
	    // progress bar item
	    _("Save module configuration"),
	    // progress bar item
            _("Save sound card information"),
	    // progress bar item
	    _("Save sysconfig values"),
	    // progress bar item
	    _("Start sound card"),
	    // progress bar item
	    _("Store volume"),
	    // progress bar item
	    _("Store joystick settings")
	    ];

    list<string> stones2 = [
	    // progress bar item
	    _("Saving sound card settings..."),
	    // progress bar item
	    _("Saving card information..."),
	    // progress bar item
	    _("Saving sysconfig values..."),
	    // progress bar item
	    _("Starting sound card..."),
	    // progress bar item
	    _("Storing volume settings..."),
	    // progress bar item
	    _("Storing joystick settings..."),
	    ];

    if (install && !Mode::autoinst())
    {
	// progress bar item
	stones = add(stones, _("Install required packages"));

	// progress bar item
	stones2 = add(stones2, _("Installing required packages..."));
    }


    // not really necessary for Progress stuf (it is set off in _auto client)
    if (!Sound::write_only)
    {
	// progres bar label
	Progress::New (_("Saving sound card settings..."), " ", size(stones) - 1,
		// progres bar label
		stones, stones2, _("Saving sound card settings..."));
        if (Sound::use_ui)
	    Wizard::DisableAbortButton();
    }

    Progress::NextStage();

    list<string> reqmodules = [];

    // in autoyast installation the packages are installed by autoyast
    // see sound_auto.ycp - it's called with "Packages" argument
    if (!Mode::autoinst())
    {
	// get required sound and joystick kernel modules
	reqmodules = Sound::RequiredKernelModules();
	list<string> reqjoymodules = Joystick::RequiredKernelModules();

	if (reqmodules == nil)
	{
	    reqmodules = [];
	}

	if (reqjoymodules == nil)
	{
	    reqjoymodules = [];
	}

	// merge lists, remove duplicates
	reqmodules = (list<string>) union(reqmodules, reqjoymodules);

	if (size(reqmodules) > 0)
	{
	    // ensure that all required kernel modules are installed
	    Package::InstallKernel(reqmodules);
	}
    }

    // save config to /etc/modprobe.d/50-sound.conf
    SaveModulesEntry(save_info, []);

    sleep(10);
    Progress::NextStage();

    Sound::StoreUniqueKeys();

    sleep(10);
    Progress::NextStage();

    SaveRCValues(rc_values);

    y2milestone("Sound::write_only: %1", Sound::write_only);

    sleep(10);
    Progress::NextStage();


    list configuredcards = Sound::GetSoundCardList();
    if (!Sound::write_only)
    {
	// stop joystick before restarting ALSA
	string cmd = joy_cmd + " unload";
	y2milestone("Executing: %1", cmd);
	SCR::Execute(.target.bash, cmd);

	// restart ALSA
	if (size(configuredcards) > 0)
	{
	    cmd = alsa_cmd + " reload";
	    y2milestone("Executing: %1", cmd);
	    SCR::Execute(.target.bash, cmd);
	}
    }

    Progress::NextStage();

    // initialize mixer settings
    if (Mode::installation() || SCR::Read(.target.size, Sound::asound_state()) == -1 || Sound::write_only)
    {
	integer i = 0;
	maplist (map e, (list<map>) save_info, ``{
	    Sound::InitMixer (i, e["module"]:"");
	    i = i + 1;
	});
	y2milestone("Mixer is initialized");
    }
    else
    {
	y2milestone("Mixer was not initialized during saving");
    }

    if (size(configuredcards) > 0)
    {
	logmixer("Mixer status before saving the volume");
	y2milestone("volume_settings: %1", Sound::volume_settings);

	SaveVolume();
	logmixer("Mixer status after saving the volume");

	if (Sound::write_only && haskey (settings, "volume_settings"))
	{
	    set_vol_settings (vol_settings);
	}
    }

    sleep(10);
    Progress::NextStage();

    // abort block for read/write dialogs
    block<boolean> abort_block = ``{ return false; };

    // write joystick configuration
    Joystick::Write (abort_block);

    if (install && !Mode::autoinst())
    {
	Progress::NextStage();
	install_packages(reqmodules);
    }

    if (size(configuredcards) > 0)
    {
	// enable alsasound service in runlevels 2,3,5
	Service::Finetune("alsasound", ["2", "3", "5"]);
    }
    else
    {
	// disable sound service - it's not needed, no soundcard is present
	Service::Adjust("joystick", "disable");
	Service::Adjust("alsasound", "disable");
    }

    return true;// TODO return value!
}
