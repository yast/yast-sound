/**
 *
 * File:
 *   options.ycp
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   Module for setting options passed to the module
 *
 * String corrections by Christian Steinruecken <cstein@suse.de>, 2001/08/01
 *
 *
 * Authors:
 *   Dan Vesely <dan@suse.cz>
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * parameters: 1st: parameter list
 *
 */

{

    textdomain "sound";

    import "Sound";
    import "Wizard";
    import "Label";
    import "Popup";
    import "String";
    import "Report";

    include "sound/ui.ycp"; // ReallyAbort
    include "sound/routines.ycp"; // get_module_params, restore_mod_params

    /**
     * checks whether param #1 is if type of param #2
     * @param value value
     * @param type expected type. one of {int, string}
     * @param poss if poss is nonempty, checks if value is one of them
     * returns error message, empty string if ok
     * @return string error message
     */
    define string check_value (string value, string type, list<string> poss) ``{
        if (type == "int")
        {
            if (tolower(substring (value, 0, 2)) == "0x")	// hex number
            {
                string rest = tolower(substring (value, 2));
                if (filterchars(rest, "0123456789abcdef") != rest)
                {
                      // To translators: popup message, wrong value
                      return sformat (_("The value: %1 must be a number"), value);
                }
            }
            else                // decimal number
            {
                string rest = value;
                if (substring (value, 0, 1) == "-")      // negative number
                {
                    rest = substring (value, 1);
                }
                if (filterchars(rest, "0123456789") != rest)
                {
                    // To translators: popup message, wrong value
                    return sformat (_("The value: %1 must be a number"), value);
                }
            }
        }
        else if (type == "string")
        {
            if (filterchars (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789-") != value)
            {

                integer wrong_pos = findfirstnotof (tolower (value), "abcdefghijklmnopqrstuvwxyz_0123456789-");
                string wrong_char = substring (value, wrong_pos, 1);
                if (wrong_char == " ")
                {
                    // To translators: "space" means blank character
                    wrong_char = wrong_char + " " + _("(space)");
                }
                // To translators: popup message, wrong value
                return  sformat (_("String cannot contain: %1"), wrong_char);
            }
        }

        // now check for poss list
        if (size (poss) > 0)
        {
            list poss_list = [];

            if (type != "int")
            {
                poss_list = maplist (string v, poss, ``(value == v));
            }

            if (!contains (poss_list, true))
            {
                // popup message: wrong value; %1 is list of right values
                return sformat (_("The value must be one of
%1"), mergestring (poss,","));
            }
        }

        return "";  // ok :-)
    }

    /**
     *  creates itemized table entries,
     *  @param lm list of maps to take keys from
     *  @param lk list of keys to look for in 1st param
     *  @return list of items
     */
    define list<term> create_table (list lm, list lk) ``{
	list<term> res = [];
	integer pos = 0;
	foreach (map<string,any> m, (list<map<string,any> >) lm, ``{
	    res = add(res, `item(`id(pos),
		m[lk[0]:""]:"",
		m[lk[1]:""]:"",
		m[lk[2]:""]:""
	    ));
	    pos = pos + 1;
	});
	return res;
    }

    /**
     * parses string (eg. '{{0,2},{0,100,20}}') to a list
     * (in this case [0,1,2,0,20,40,60,80,100])
     * @param input input string
     * @return list of possible values
     */
    define list parse_bracket(string input) ``{

        string inner	= input; // substring(input, 1, size(input)-2);
        integer siz	= size(inner);
        integer pos	= 0;
        integer oldpos	= 0;
        list output	= [];

        while (pos < siz)
        {
            if (substring(inner, pos, 1) == "{")
            {
                oldpos = pos;
                pos = pos + 1;
                integer cnter = 1;
                // let's find the pair bracket for '{'
                while ((cnter > 0) && (pos < siz))
                {
                    if (substring(inner, pos, 1) == "}")
                    {
                        cnter = cnter - 1;
                    }
                    else if (substring(inner, pos, 1) == "{")
                    {
                        cnter = cnter + 1;
                    }
                    pos = pos + 1;
                }
                output = add (output,
		    parse_bracket(substring(inner, oldpos+1, pos - oldpos-2)));
                pos = pos + 1;
            }
            else
            {
                oldpos = pos;
                while ((substring(inner, pos, 1) != ",") && pos < siz)
                {
                    pos = pos + 1;
                }
                output = add(output, substring(inner, oldpos, pos - oldpos));
                pos = pos + 1;
            }
        }
        return output;
    }

    /**
     * gets an 'modules.generic_string' like options description string
     * and returns a list of possible values
     * @param input string
     * @return list of values
     */
    define list<string> string2vallist(string input) ``{
	boolean parse_error	= false;
	list l			= flatten ((list<list>)parse_bracket(input));

	l = maplist(list<any> e, (list<list<any> >) l, ``{
	    if (size(e) == 0)
	    {
		return [];
	    }
	    if (size(e) == 1)
	    {
		return e;
	    }

	    integer step = 1;
	    if (size(e) == 3)
	    {
		step = tointeger (e[2]:"1");
	    }
	    if (step < 1)
	    {
		parse_error = true;
		return [];
	    }

	    boolean hex = false;
	    if (regexpmatch (e[1]:"", "^-[0-9]*$") ||
		regexpmatch (e[1]:"", "^[0-9]*$"))
	    {
		hex = false;
	    }
	    else if (regexpmatch (e[1]:"", "^-0x[0-9a-fA-F]*") ||
		     regexpmatch (e[1]:"", "^0x[0-9a-fA-F]*"))
	    {
		hex = true;
	    }
	    else
	    {
		if (contains(["Disabled", "Enabled"], e[1]:""))
		{
		    return [ e[0]:"" ];
		}
	    }

	    integer from = tointeger (e[0]:"");
	    integer to = tointeger (e[1]:"");

	    if (((to - from) / step) > 50)
	    {
		// too many values :(
		parse_error = true;
		return [];
	    }

	    list<string> outlist = [];

	    while (from <= to)
	    {
		if (hex)
		{
		    outlist = add(outlist, tohexstring(from));
		}
		else
		{
		    outlist = add(outlist, sformat("%1", from));
		}
		from = from + step;
	    }
	    return outlist;
	});

	l = flatten((list<list>) l);

	if (parse_error)
	{
	    y2debug("parse error: %1", input);
	}

	return (list<string>) l;
    }

    /**
     * default widget when there are no known values
     * @return term widget
     */
    define term defWidget() ``{
	// label text
	return `Label(_("Possible value:\nnot known"));
    }

    /**
     * widget for choosing one value from list
     * @param vals string with values eg. "12,3,4,6"
     * @param preselected string default value (preselected in combo)
     * @return term combobox widget
     */
    define list<term> gen_list(list<string> vals, string preselected) ``{
	list<term> vls = maplist (string e, vals, ``(`item(`id(e), e, preselected == e)));
	return vls;
    }

    /**
     * when the selected option in table is changed, we need to update
     * combo with values
     * @param values list of values
     * @param default_item default item
     * @return void
     */
    define list<term> getPossibleValues(string values, string default_item) ``{
	list<string> values_list = string2vallist(values);

	if (!contains(values_list, default_item))
	{
	    values_list = prepend(values_list, default_item);
	}

	list<term> widg = gen_list(values_list, default_item);
	return widg;
    }

    define map OptionPopup(string headline, string name, string value, boolean new_option, string possible_values)
    {
	y2milestone("possible_values: %1", possible_values);

	term button_box = `ButtonBox (
	    `PushButton( `id(`ok), `opt(`okButton, `default, `key_F10), Label::OKButton()),
	    `PushButton( `id(`cancel), `opt(`cancelButton, `key_F9), Label::CancelButton())
	);

	list<term> items = getPossibleValues(possible_values, value);

	term content = `VBox(
	    `Heading(headline),
	    `VSpacing(0.2),
	    new_option ?
		`VBox(
		    `Left(`TextEntry(`id(`option_name), _("Name of the &Option"), name)),
		    `VSpacing(0.2)
		)
		: `Empty(),
	    (size(string2vallist(possible_values)) > 0) ?
		`ComboBox(`id(`option_value), `opt(`editable, `hstretch), new_option ? _("&Value") :  _("&Option: ") + name, items)
		: `Left(`TextEntry(`id(`option_value), new_option ? _("&Value") :  _("&Option: ") + name, value)),
	    `VSpacing(0.2),
	    button_box
	);

	UI::OpenDialog(`opt(`decorated), content);

	any ret = nil;
	string option_name = "";
	string option_value = "";

	while(true)
	{
	    ret = UI::UserInput();

	    // validate the input
	    option_name = new_option ? (string)UI::QueryWidget(`id(`option_name), `Value) : name;
	    option_value = (string)UI::QueryWidget(`id(`option_value), `Value);

	    // do not validate if the Cancel button has been pressed
	    if (ret == `cancel)
	    {
		break;
	    }

	    // all non-ASCII characters from value
	    string extra_chars = deletechars(option_value, String::CGraph());

	    if (extra_chars != "")
	    {
		Report::Error(sformat(_("Value of the option contains invalid\ncharacters '%1'.\n\nEnter a valid value."), extra_chars));
		UI::SetFocus(`id(`option_value));
		continue;
	    }

	    // check the option name if it's entered by user
	    if (new_option)
	    {
		// all non-ASCII characters from name
		extra_chars = deletechars(option_name, String::CGraph());

		if (extra_chars != "")
		{
		    Report::Error(sformat(_("Name of the option contains invalid\ncharacters '%1'.\n\nEnter a valid name."), extra_chars));
		    UI::SetFocus(`id(`option_name));
		    continue;
		}
	    }

	    break;
	}

	UI::CloseDialog();

	return $[ "ui":ret, "option_name":option_name, "option_value":option_value ];
    }

    define map ChangePopup(string option, string value, string possible_values)
    {
	return OptionPopup(_("Change the Option"), option, value, false, possible_values);
    }

    define map AddPopup()
    {
	return OptionPopup(_("Add a New Option"), "", "", true, "");
    }

    /**
     * Returns description of card module option
     * @param arg type of arg can be string or list
     * @return string description
     */
    define string getDescr(any arg) ``{
	if (is(arg, string))
	{
	    return (string) arg;
	}
	if (is(arg, list))
	{
	    list larg = (list) arg;
	    return sformat(larg[0]:"%1", larg[1]:"");
	}
	return _("No description available");
    }

    /**
     *	UI controls for options setting dialog
     *
     *  @param cardlabel card model string
     *  @param itemized_descriptions option list (preformated using
     *		'create_table' with tripples: description, name, value)
     *  @param current_option_name initially selected item name
     *  @param current_option_value value of current option
     *  @return term options dialog contents
     *  @see options#OptionsDialog
     */
    define term OptionsCon (string cardlabel, list itemized_descriptions,
		    string current_option_name, string current_option_value) ``{

	return `HBox (
	    `HSpacing (3),
	    `VBox (
		`VSquash(`Top(`Label (`opt(`outputField), cardlabel))),
                `VSpacing (),
		`Table (`id(`table), `opt (`notify, `immediate), `header(
		    // Table header -- option description
		    _("Description"),
		    // Table header -- option name
		    _("Option"),
		    // Table header -- value of an option
		    `Right(_("Value"))), itemized_descriptions),
                `VSpacing (0.5),
		`HBox (
		    `PushButton (`id (`add), Label::AddButton()),
		    `PushButton (`id (`edit), Label::EditButton()),
		    `PushButton (`id (`delete), Label::DeleteButton()),
		    `HStretch(),
		    // restore original option values
		    `PushButton (`id (`reset), _("R&eset all"))
		),
                `VSpacing (1)
            ),
	    `HSpacing (3)
        );
    }

    define void RefreshDelete(boolean enabled)
    {
	y2milestone("Delete button enabled: %1", enabled);
	UI::ChangeWidget(`id(`delete), `Enabled, enabled);
    }

    define void RefreshUI(list<term> items, integer index, boolean enable_delete)
    {
	// refresh the table
	UI::ChangeWidget(`id(`table), `Items, items);

	if (index != nil)
	{
	    UI::ChangeWidget(`id(`table), `CurrentItem, index);
	}

	RefreshDelete(enable_delete);
    }

    /**
     * displays dialog with card options
     *
     * @param cardlabel string label for the card
     * @param opts list. list where each item is map
     *        with keys: name, value, type, default, description.
     *	      values in map are strings
     * @return map result
     */
    define map OptionsDialog (string cardlabel, map opts, string driver) ``{

	string help_text = Sound::STRINGS["OptionsDialog"]:"";

	map origOptions = opts;

	map module_params = get_module_params(driver);
	list<string> all_options = maplist(string name, map o, (map<string,map>)module_params, {return name;});

	list options = maplist (string name, map<string,any> o,
	    (map <string, map <string, any> >) opts, ``($[
	    // label: description of option is not available
	    "description" : getDescr(o["descr"]:nil),
	    "name"	  : name,
	    "value"	  : o["value"]:"",
	    "type"        : o["type"]:"string",
	    "default"     : o["default"]:""]
	));

	list<term> itemized_descriptions = create_table (options,
	    ["description", "name", "value"]);

	integer current_option = 0;
	string current_option_name = options[current_option, "name"]:"";

	term con = OptionsCon (cardlabel, itemized_descriptions,
		    current_option_name, options[current_option, "value"]:"");

	// dialog title
	Wizard::SetContents (_("Sound Card Advanced Options"), con, help_text,
	    true, true);

	if (size (itemized_descriptions) > 0)
	{
	    UI::ChangeWidget(`id(`table), `CurrentItem, 0);
	    UI::SetFocus (`id(`table));
	}
	else
	{
	    Popup::Message(_("There are no options for this module"));
	}


	// set initial Delete state
	symbol ui = `table;

	if (size (itemized_descriptions) == 0)
	    ui = `no;

	repeat
	{
	    current_option = (integer) UI::QueryWidget (`id(`table), `CurrentItem);
	    term curr_opt = (term) UI::QueryWidget(`id(`table), `Item(current_option));
	    current_option_name = curr_opt[2]:"";
	    string current_option_value = curr_opt[3]:"";

	    if (ui == `table)
	    {
		// enable/disable Delete button
		RefreshDelete(!contains(all_options, current_option_name));
	    }
	    else if (ui == `add)
	    {
		map result  = AddPopup();
		y2milestone("New option: %1", result);

		if (result["ui"]:`cancel == `ok)
		{
		    // update table
		    string value = result["option_value"]:"";
		    string name = result["option_name"]:"";

		    if (name != "")
		    {
			integer index = size(itemized_descriptions);

			// remember the new value
			itemized_descriptions = add(itemized_descriptions,
			    `item(`id(index), "", name, value)
			);

			RefreshUI(itemized_descriptions, index, !contains(all_options, name));
		    }
		}
	    }
	    else if (ui == `edit)
	    {
		string possible_values = origOptions[current_option_name, "allows"]:"";

		while (true)
		{
		    map result  = ChangePopup(current_option_name, current_option_value, possible_values);
		    y2milestone("Modified option: %1", result);

		    if (result["ui"]:`cancel == `ok)
		    {
			string value = result["option_value"]:"";

			// check the value
			string err = check_value(value, options [current_option, "type"]:"string", string2vallist(possible_values));
			if (size (err) > 0)	// error - wrong value
			{
			    // display message and display the popup again in the loop
			    Popup::Message(err);
			}
			else
			{
			    UI::ChangeWidget(`id(`table), `Item(current_option, 2), value);

			    // update the value
			    list<term> tmp = [];
			    maplist (term e, itemized_descriptions, ``{
				if (current_option == e[0,0]:0)
				{
				    tmp = add (tmp, `item(`id (current_option),
					e[1]:"", e[2]:"", value));
				}
				else
				    tmp = add (tmp, e);
			    });
			    itemized_descriptions = tmp;
			    break;
			}
		    }
		    else
		    {
			break;
		    }
		}
	    }
	    else if (ui == `delete)
	    {
		y2milestone("Removed option: %1", current_option_name);

		// update the value
		list<term> tmp = [];
		maplist (term e, itemized_descriptions, ``{
		    if (current_option != e[0,0]:0)
		    {
			tmp = add (tmp, e);
		    }
		});
		itemized_descriptions = tmp;

		y2milestone("itemized_descriptions[0,2]: %1", itemized_descriptions[0,2]:"");
		// set Delete status according to the new first item
		RefreshUI(itemized_descriptions, nil, !contains(all_options, itemized_descriptions[0,2]:""));
	    }
	    else if (ui == `reset &&
		    // popup question
		    Popup::YesNo(_("Do you really want to reset all values?")))
	    {
		integer i = 0;
		while (i < size (itemized_descriptions))
		{
		    UI::ChangeWidget (`id(`table), `Item(i, 2),
			options[i,"default"]:"");
		    // reset the values in items list
		    term e = itemized_descriptions [i]:`item(`id(i),"","","");
		    itemized_descriptions [i] =
			`item (e[0]:`id(i), e[1]:"",
			       e[2]:"", options[i,"default"]:"");
		    i = i + 1;
		}
	    }
	    else if (ui == `abort || ui == `cancel)
	    {
		if (ReallyAbort())
		{
		    ui = `abort;
		    break;
		}
	    }
	    ui = (symbol) UI::UserInput();
	} until (ui == `back || ui == `next || ui == `cancel);

	y2milestone("ui: %1, itemized_descriptions: %2", ui, itemized_descriptions);

	return $["ui" : ui, "return" : itemized_descriptions];
    }

    /**
     * just calls options dialog
     * @param save_entry map with card configuration
     * @return map result
     */
    define map sound_options(map save_entry) ``{

	string modname	= save_entry["module"]:"";
	string label	= save_entry["model"]:"";
	map params	= get_module_params (modname);
	y2milestone("params: %1", params);
	params		= restore_mod_params (params,save_entry["options"]:$[]);
	y2milestone("params: %1", params);

	Wizard::RestoreNextButton();

	// now show the dialog
	map result	= OptionsDialog (label, params, modname);
	list<term> vals	= result["return"]:[];

	// convert from table entries (items) back to card
	map opts = $[];
	foreach (term it, vals, ``{
	    if (it[3]:"" != "")
	    {
		opts = add(opts, it[2]:"", it[3]:"");
	    }
	});

	y2milestone("New options: %1", opts);

	save_entry = add(save_entry, "options", opts);

	return $["ui" : result["ui"]:`cancel, "return" : save_entry];
    }

}//EOF
