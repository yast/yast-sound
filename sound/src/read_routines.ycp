/**
 * File:
 *   read_routines.ycp
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   Routines for reading sound card configuration
 *
 * Authors:
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 */

{
    import "Sound";
    import "HWConfig";
    import "Confirm";
    import "String";

    include "sound/routines.ycp";// for is_snd_alias()

    textdomain "sound";

    /**
     * tries to determine card model name from audio.alsa agent
     * @param card_id card id
     * @return card name, "Sound card" on failure
     */
    define string read_card_name_from_alsa(integer card_id) ``{
	path pth = topath(sformat(".audio.alsa.cards.%1.name", card_id));
	string name = (string) SCR::Read(pth);
	if (name == nil)
	{
	    return "Sound card";
	}
	return name;
    }


    /**
     * Extacts the unique key and the name of the card from comment in the
     * modules.conf placed before char-major-81-x
     * @param comment before the char-major-81-x
     * @return map example: $[ "unique_key" : string, "name" : string ] or nil
     */
    define map extractUniqueKey (string comment) ``{
	map result = nil;

	// split to lines
	list<string> comment_lines = splitstring (comment, "\n");

	// find last line with a ":"
	string line_with_uk = "";
	integer colon_pos_uk = nil;
	foreach(string line, comment_lines, ``{
	    integer c_pos = findfirstof (line, ":");
	    if (c_pos != nil)
	    {
		line_with_uk = line;
		colon_pos_uk = c_pos;
	    }
	});

	// did we find it?
	if (colon_pos_uk != nil)
	{
	    // extract name
	    string name = substring (line_with_uk, colon_pos_uk + 1,
				     size(line_with_uk) - colon_pos_uk - 1);
	    // extract unique key
	    integer start_uk = findfirstnotof (line_with_uk, "# \t");
	    string uk = substring (line_with_uk, start_uk,
				  colon_pos_uk - start_uk);

	    result = $[ "name" : name, "unique_key" : uk ];
	}
	return result;
    }

    // sort module aliases according to snd slots option
    list<string> sort_aliases(path config_path, path alias_path, list<string> aliases)
    {
	// read 'snd' options
	map<string,string> snd_opts = (map<string,string>)SCR::Read(add(config_path, "snd"));
	y2milestone("snd optionss: %1", snd_opts);

	list<string> slots_option = splitstring(snd_opts["slots"]:"", ",");
	slots_option = maplist(string slotopt, slots_option,
	    {
		return String::CutBlanks(slotopt);
	    }
	);

	// alias -> driver mapping
	map<string,string> alias_mapping = $[];

	// read aliases
	foreach(string a, aliases,
	    {
		y2milestone("Reading alias %1", a);
		string modname	= (string)SCR::Read(add(alias_path, a));
		alias_mapping = add(alias_mapping, a, modname);
	    }
	);

	// driver -> [ aliases ]
	map<string, list<string> > driver_mapping = $[];

	// create a reverse mapping
	foreach(string alias, string driver, alias_mapping,
	    {
		list<string> a_list = driver_mapping[driver]:[];
		a_list = add(a_list, alias);

		driver_mapping[driver] = a_list;
	    }
	);

	y2milestone("Driver mapping: %1", driver_mapping);

	list<string> sorted_aliases = [];

	// sort aliases
	foreach(string slot, slots_option,
	    {
		list<string> aliases = driver_mapping[slot]:[];

		sorted_aliases = add(sorted_aliases, aliases[0]:"");

		aliases = remove(aliases, 0);
		driver_mapping[slot] = aliases;
	    }
	);

	return sorted_aliases;
    }


    /**
     * reads already saved info from given file
     * @return list
     */
    define list<map> read_modprobe (path mod_path) ``{

        list<map> save	= [];	// structure to save

	/*
	path mod_path	= .modprobe_sound;

	// read from /etc/modprobe/conf if /etc/modprobe.d/50-sound.conf is not present
	if (SCR::Read(.target.size, "/etc/modprobe.d/50-sound.conf") == -1)
	{
	    mod_path			= .modules;
	    Sound::used_modprobe_conf	= true;
	}
	*/

	path mod_alias	= add (mod_path, "alias");
	path mod_options= add (mod_path, "options");

	list<string> aliases = (list<string>) SCR::Read (mod_alias);

	aliases = filter(string a, aliases, ``(is_snd_alias(a)));

	// since parameters in modules options are separated by comas
	// (eg. options mod snd_id=1,2,3, snd_index=1,2,3),
	// we have to count occurences for each module
	integer position = -1;
	map mod_occur	= $[];			// alsa modules

	list<map> det_cards = [];

	/* Confirmation: label text (detecting hardware: xxx) */
	if (!Confirm::Detection (_("Sound Cards"), "yast-sound"))
	{
	    det_cards = [];
	    Sound::skip_detection = true;
	}
	else
	{
	    det_cards = (list<map>)SCR::Read(.probe.sound);
	}

	y2milestone("Detected cards: %1", det_cards);

	// sort the aliases according to the slots option
	aliases = sort_aliases(mod_options, mod_alias, aliases);

	y2milestone("Sorted aliases acording to slots: %1", aliases);

	foreach (string a, aliases, ``{
	    y2milestone("Reading alias %1", a);

	    position		= position + 1;
	    string modname	= (string) SCR::Read (add (mod_alias, a));
	    integer opt_pos	= mod_occur[modname]:0;

	    mod_occur	= add (mod_occur, modname, mod_occur[modname]:0 + 1);

	    map<string,string> opts = (map<string,string>)
		SCR::Read(add (mod_options, modname));
	    map options = $[];
	    foreach (string name, string val, opts, ``{
		list vals = splitstring(val, ",");
		if (size(val) > opt_pos)
		{
		    options = add (options, name, vals[opt_pos]:"");
		}
	    });

	    // read card info from the comment string
	    string comment = (string)
		SCR::Read(add (add (mod_alias,a), "comment"));
	    string uniq		= "";
	    string model	= "";
	    map res		= extractUniqueKey(comment);

	    if (res != nil)
	    {
		uniq	= res["unique_key"]:"";
		model	= res["name"]:"";
	    }
	    else
	    {
		// probably system upgrade
		uniq	= isa_uniq();
		model	= read_card_name_from_alsa (position);
	    }

	    // add index option
	    options["index"] = tostring(position);

	    map entry = $[
		"alias"		: a,
		"module"	: modname,
		"options"	: options,
		"unique_key"	: uniq,
		"model"		: model
	    ];

	    foreach(map dcard, det_cards, {
		    if (dcard["unique_key"]:"" == uniq)
		    {
			y2debug("Found uniq %1: %2", uniq, dcard);
			if (haskey(dcard, "bus_hwcfg") && haskey(dcard, "sysfs_bus_id"))
			{
			    entry["bus"] = dcard["bus_hwcfg"]:"";
			    entry["bus_id"] = dcard["sysfs_bus_id"]:"";
			    entry["vendor_id"] = dcard["vendor_id"]:0;
			    entry["sub_vendor_id"] = dcard["sub_vendor_id"]:0;
			    entry["device_id"] = dcard["device_id"]:0;
			    entry["sub_device_id"] = dcard["sub_device_id"]:0;
			}
		    }
		}
	    );

	    y2debug("entry: %1", entry);

	    save = add (save, entry);
	});
        return save;
    }

    /**
     * reads already saved info from modules.conf
     * @example of return value:
     * [
     *	    $[
     *		"alias":    "snd-card-0",
     *		"module":   "snd-card-emu10k1",
     *		"options":  ["snd_id":"0", "snd_index":"card1"],
     *		"unique_key":"asdf.asdfasdfasdf",
     *		"model":    "Sound Blaster Live!"
     *	    ],
     *	    $[...]
     *	]
     * @return list
     */
    define list<map> read_save_info () ``{
	list<map> saved = [];

	// First, read from /etc/modprobe.d/50-sound.conf
	if (SCR::Read(.target.size, "/etc/modprobe.d/50-sound.conf") >= 0)
	{
	    saved = read_modprobe (.modprobe_sound);
	}
	else
	{
	    y2milestone("/etc/modprobe.d/50-sound.conf doesn't exist");

	    // try /etc/modprobe.conf...
	    if (SCR::Read(.target.size, "/etc/modprobe.conf") >= 0)
	    {
		saved = read_modprobe (.modules);

		if (saved != [])
		{
		    Sound::used_modprobe_conf	= true;
		}
	    }
	    else
	    {
		y2milestone("/etc/modprobe.conf doesn't exist");
	    }
	}

	return saved;
    }

    define list<map> read_hwconfig() {

	list<map> ret = [];

	// get list of all config files
	list<string> cfiles = HWConfig::ConfigFiles();

	// read module options
	list<map> mod_opts = read_save_info();
	y2milestone("mod_opts: %1", mod_opts);

	map<string, map> cardopts = $[];
	map<string, any> ids = $[];
	foreach(map op, mod_opts, {
		cardopts[op["alias"]:""] = op["options"]:$[];

		map idmap = $[];

		if (op["vendor_id"]:0 != 0 && op["device_id"]:0 != 0)
		{
		    idmap["vendor_id"] = op["vendor_id"]:0;
		    idmap["device_id"] = op["device_id"]:0;
		}
		if (op["sub_vendor_id"]:0 != 0 && op["sub_device_id"]:0 != 0)
		{
		    idmap["sub_vendor_id"] = op["sub_vendor_id"]:0;
		    idmap["sub_device_id"] = op["sub_device_id"]:0;
		}
		if (op["bus"]:"" != "")
		{
		    idmap["bus"] = op["bus"]:"";
		}

		ids[op["unique_key"]:""] = idmap;
	    }
	);

	y2milestone("read module options: %1", cardopts);
	y2milestone("read IDs: %1", ids);

	// scan each config file - search for sound card config
	foreach(string cfile, cfiles, {
	    string com = HWConfig::GetComment(cfile, "MODULE");

	    if (com != nil)
	    {
		list<string> coms = splitstring(com, "\n");
		boolean sound_card_found = false;
		map entry = $[];

		foreach(string comline, coms, {

			if (regexpmatch(comline, "^# YaST configured sound card snd-card-[0-9]*"))
			{
			    string alias = regexpsub(comline, "^# YaST configured sound card (snd-card-[0-9]*)", "\\1");

			    if (alias != nil)
			    {
				entry["hwcfg"] = cfile;
				entry["alias"] = alias;

				// if the file uses the old config then force update
				if (regexpmatch(cfile, "^bus-pci-"))
				{
				    y2milestone("detected old configuration file (%1), forced update of the configuration", cfile);
				    Sound::SetModified();
				}

				map opts = cardopts[alias]:$[];

				if (size(opts) > 0)
				{
				    entry["options"] = opts;
				}

				sound_card_found = true;
			    }
			}
			else if (regexpmatch(comline, "^# ....\\............:.*"))
			{
			    string uniq = regexpsub(comline, "^# (....\\............):(.*)", "\\1");
			    string name = regexpsub(comline, "^# (....\\............):(.*)", "\\2");

			    if (uniq != nil)
			    {
				entry["unique_key"] = uniq;

				// add vendor/device ID
				map idmap = ids[uniq]:$[];
				entry = union(entry, idmap);
			    }

			    if (name != nil)
			    {
				entry["model"] = name;
			    }
			    else
			    {
				entry["model"] = _("Unknown");
			    }
			}
		    }
		);

		string m = HWConfig::GetValue(cfile, "MODULE");
		if (m != nil)
		{
		    entry["module"] = m;
		}

		// TODO add bus ID

		if (sound_card_found)
		{
		    y2milestone("Found sound card hwconfig (%1): %2", cfile, entry);
		    ret = add(ret, entry);
		}
	    }
	}
	);

	return ret;
    }

}//EOF
