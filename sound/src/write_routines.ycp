/**
 *
 * $Id$
 *
 * File:
 *   write_routines.ycp
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   API for writings sound configuration
 *
 * Authors:
 *   Dan Vesely <dan@suse.cz>
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 *
 */

{
    textdomain "sound";

    import "Arch";
    import "Sound";
    import "HWConfig";
    include "sound/routines.ycp";

    /**
     * create special comment for given model
     * @param model card description
     * @param uniq_key unique key
     * @return string comment for the alias
     */

    define string createAliasComment(string model, string uniq_key) ``{
	string comment = "# " + uniq_key + ":" + model + "\n";
	return comment;
    }

    define string tounprefixedhexstring(integer i) {
	if (i == nil)
	{
	    return "";
	}

	string hex = tohexstring(i);

	// remove '0x' prefix, ignore bus type prefix if it is present
	integer i = (size(hex) > 6) ? 3 : 2;

	return substring(hex, i);
    }

    /**
     * Saves one '/etc/modules.conf' entry
     * @param entry card config
     * @return boolean success/failure
     */
    define boolean SaveOneModulesEntry (map entry) ``{

        path mod_alias	= add (.modprobe_sound.alias, entry ["alias"]:"off");
        path mod_alias_comment	=
            add ( add (.modprobe_sound.alias, entry ["alias"]:"off"),"comment");

	y2milestone("Save card: %1", entry);

	// remove the old configuration file
	if (entry["hwcfg"]:"" != "")
	{
	    string rm = "rm -f /etc/sysconfig/hardware/hwcfg-" + entry["hwcfg"]:"";
	    y2milestone("Removing old configuration file: %1", rm);
	    SCR::Execute(.target.bash, rm);
	}

        boolean ret = true;
        if (haskey (entry, "alias"))
        {
	    string module_name = entry["module"]:"" ;
	    // this is a hack for snd-aoa driver, additional modules are needed (#217300)
	    if (module_name == "snd-aoa")
	    {
		// write the extra module (snd-aoa-i2sbus) to /etc/init.d/sound, add "00" suffix to the alias
		path extra_alias = add(.modprobe_sound.alias, (entry["alias"]:"off") + "00");
		ret = ret && SCR::Write(extra_alias, "snd-aoa-i2sbus");
		string extra_comment = createAliasComment(entry["model"]: "", entry["unique_key"]:"");
		ret = ret && SCR::Write(extra_alias + "comment", "# Extra driver for sound card:\n" + extra_comment);

		// write the extra module (snd-aoa-fabric-layout) to /etc/init.d/sound, add "01" suffix to the alias
		path extra_alias2 = add(.modprobe_sound.alias, (entry["alias"]:"off") + "01");
		ret = ret && SCR::Write(extra_alias2, "snd-aoa-fabric-layout");
		string extra_comment2 = createAliasComment(entry["model"]: "", entry["unique_key"]:"");
		ret = ret && SCR::Write(extra_alias2 + "comment", "# Extra driver for sound card:\n" + extra_comment);
	    }

	    string modcomment = createAliasComment(entry["model"]: "", entry["unique_key"]:"");

            ret = ret && SCR::Write(mod_alias, module_name);
	    ret = ret && SCR::Write(mod_alias_comment, modcomment);

	    // load the module automatically on boot
	    if (entry["bus"]:"" != "pci" && entry["bus"]:"" != "usb" && module_name != "")
	    {
		y2milestone("The soundcard is not attached to PCI or USB");

		string on_boot_sysconfig = (string)SCR::Read(.sysconfig.kernel.MODULES_LOADED_ON_BOOT);
		y2milestone("/etc/sysconfig/kernel:MODULES_LOADED_ON_BOOT: %1", on_boot_sysconfig);

		list<string> on_boot_modules = splitstring(on_boot_sysconfig, " ");
		on_boot_modules = filter(string mod, on_boot_modules, {return mod != nil && mod != "";});
		y2milestone("Load modules: %1", on_boot_modules);

		// add the module to sysconfig if it is missing
		if (!contains(on_boot_modules, module_name))
		{
		    y2milestone("Adding %1 to MODULES_LOADED_ON_BOOT", module_name);
		    if (on_boot_sysconfig != "")
		    {
			on_boot_sysconfig = on_boot_sysconfig + " ";
		    }

		    on_boot_sysconfig = on_boot_sysconfig + module_name;
		    y2milestone("New MODULES_LOADED_ON_BOOT value: %1", on_boot_sysconfig);

		    ret = ret && SCR::Write(.sysconfig.kernel.MODULES_LOADED_ON_BOOT, on_boot_sysconfig);
		}
	    }
        }
        return ret;
    }

    // write 'option snd slots=<driver_list>' to the config
    void WriteSlotsOption(map<integer,string> slots)
    {
	// get the indices
	list<integer> keys = [];

	foreach(integer key, string val, slots,
	    {
		keys = add(keys, key);
	    }
	);

	keys = sort(keys);

	y2milestone("Sorted keys: %1", keys);

	list<string> drivers = [];

	foreach(integer k, keys,
	    {
		string drv = slots[k]:"";

		if (drv != "")
		{
		    if (drv == "snd-aoa")
		    {
			drv = "snd-aoa-fabric-layout";
		    }

		    drivers = add(drivers, drv);
		}
	    }
	);

	string slot_option = mergestring(drivers, ",");

	// write 'snd' options or remove the option line if there is no sound card
	if (slot_option != "")
	{
	    y2milestone("Writing slots option: %1", slot_option);
	    SCR::Write(add(.modprobe_sound.options, "snd"), $[ "slots" : slot_option ]);
	}
	else
	{
	    y2milestone("Removing slots option");
	    SCR::Write(add(.modprobe_sound.options, "snd"), nil);
	}
    }

    void RemovedUnusuedModulesFromSysconfig()
    {
	// remove unused modules from MODULES_LOADED_ON_BOOT
	string on_boot_sysconfig = (string)SCR::Read(.sysconfig.kernel.MODULES_LOADED_ON_BOOT);
	y2milestone("/etc/sysconfig/kernel:MODULES_LOADED_ON_BOOT: %1", on_boot_sysconfig);

	list<string> on_boot_modules = splitstring(on_boot_sysconfig, " ");
	on_boot_modules = filter(string mod, on_boot_modules, {return mod != nil && mod != "";});
	y2debug("Module list: %1", on_boot_modules);

	list<string> removed_modules = toset(maplist(map card, Sound::removed_info,
	    {return card["module"]:"";}));
	removed_modules = filter(string mod, removed_modules, {return mod != nil && mod != "";});

	boolean modified = false;
	foreach(string removed_module, removed_modules,
	    {
		// remove the module from sysconfig if it is there
		if (contains(on_boot_modules, removed_module))
		{
		    y2milestone("Removing %1 from MODULES_LOADED_ON_BOOT", removed_module);

		    // remove the module
		    on_boot_modules = filter(string mod, on_boot_modules, {return mod != removed_module;});
		    modified = true;
		}
	    }
	);

	// write the change
	if (modified)
	{
	    on_boot_sysconfig = mergestring(on_boot_modules, " ");
	    y2milestone("New MODULES_LOADED_ON_BOOT value: %1", on_boot_sysconfig);
	    SCR::Write(.sysconfig.kernel.MODULES_LOADED_ON_BOOT, on_boot_sysconfig);
	}
	else
	{
	    y2milestone("Nothing removed from MODULES_LOADED_ON_BOOT");
	}
    }

    /**
     * saves modules options. this function has to collect parameters that use
     * different cards that use single module and create a coma separated list of values
     * @param save_info save info
     * @return void
     */
    define void SaveModulesOptions(list save_info) ``{
	y2milestone("SaveModulesOptions: %1", save_info);

	path mod_options = .modprobe_sound.options;

	// create distinct list of all modules
	list<string> mods = toset(maplist(map card, (list<map<string,any> >) save_info,
	    ``(card["module"]:"off")));

	// remove the options for unused modules
	list<string> configured_options = [];

	if (SCR::Read(.target.size, "/etc/modprobe.d/sound") >=0 )
	{
	    configured_options = SCR::Dir(.modprobe_sound.options);
	}
	else
	{
	    // the file doesn't exist, create an empty file
	    SCR::Execute(.target.bash, "/usr/bin/touch /etc/modprobe.d/sound");
	}

	// must be called before SaveOneModulesEntry()
	// to write the module back if it is used by another configured card!!
	RemovedUnusuedModulesFromSysconfig();

	foreach(string op, configured_options,
	    {
		if (!contains(mods, op))
		{
		    y2milestone("Removing options for unused module %1", op);
		    SCR::Write( add(.modprobe_sound.options, op), nil);
		}
	    }
	);

	map<integer,string> slots = $[];

	foreach(string modname, mods, ``{
	    map res = Sound::CollectOptions(modname);

	    // remove "index" option, do not write it
	    string index = res["index"]:"";

	    if (haskey(res, "index"))
	    {
		res = remove(res, "index");
	    }

	    // remove old "enable" option if it's present
	    if (haskey(res, "enable"))
	    {
		res = remove(res, "enable");
	    }

	    list<string> indices = splitstring(index, ",");

	    foreach(string idx, indices,
		{
		    integer i = tointeger(idx);

		    if (i != nil && i >= 0)
		    {
			y2debug("adding %1 : %2", i, modname);
			slots = add(slots, i, modname);
		    }
		}
	    );

	    // at first remove the current options (writing empty options leaves the old options untouched)
	    SCR::Write( add (mod_options, modname ), nil);

	    SCR::Write( add (mod_options, modname ), res);
	});

	y2milestone("Collected slots: %1", slots);

	WriteSlotsOption(slots);
    }

    /**
     * removeOldAliases
     * @param als list with old aliases
     */
    define void removeOldEntries(list als) ``{
	if (SCR::Read(.target.size, "/etc/modprobe.d/sound") >=0 )
	{
	    maplist(string e, (list<string>) als, ``{
		if (is_snd_alias(e) ||
		    issubstring(e, "sound-service-") ||
		    issubstring(e, "sound-slot-"))
		    {
			SCR::Write( add (.modprobe_sound.alias, e), nil);
		    }
	    });
	}
    }

    /**
     * Remove sound configuration from /etc/modprobe.conf
     */
    define void RemoveOldConfiguration () ``{

	y2milestone ("removing old sound configuration from /etc/modprobe.conf (it was already saved to /etc/modprobe.d/sound)");

	path mod		= .modules;
	path mod_alias		= .modules.alias;
	path mod_options	= .modules.options;

	if (contains(SCR::Dir(mod), "alias"))
	{
	    list<string> als = (list<string>)SCR::Read(mod_alias);
	    foreach (string e, als, ``{
		if (is_snd_alias(e) ||
		    issubstring(e, "sound-service-") ||
		    issubstring(e, "sound-slot-") ||
		    e == "char-major-14" ||
		    e == "char-major-116")
		{
		    SCR::Write (add (mod_alias, e), nil);
		}
	    });
	}
	// remove also old options
	foreach (map card, Sound::modules_conf_b, ``{
	    string modname = card["module"]:"";
	    if (modname != "")
		SCR::Write (add (mod_options, modname ), nil);
	});
	SCR::Write (mod, nil);
    }

    define boolean RemoveHWConfig() {
	boolean ret = true;

	// get list of all config files
	list<string> cfiles = HWConfig::ConfigFiles();
	y2milestone("Found sysconfig/hardware files: %1", cfiles);

	// scan each config file - search for sound card config
	foreach(string cfile, cfiles, {
	    string com = HWConfig::GetComment(cfile, "MODULE");

	    if (com != nil)
	    {
		list<string> coms = splitstring(com, "\n");
		boolean sound_card_found = false;
		map entry = $[];

		foreach(string comline, coms, {

			// this is a hwconfig file crated by Yast
			// we can safely remove it
			if (regexpmatch(comline, "^# YaST configured sound card snd-card-[0-9]*"))
			{
			    y2milestone("Removing file: %1", cfile);
			    ret = ret && HWConfig::RemoveConfig(cfile);
			}
		    }
		);

		HWConfig::Flush();
	    }
	});

	return ret;
    }

    /**
     * Saves all '/etc/modprobe.d/sound' entries
     * @param save_info cards save info
     * @param system sytem dependent part
     * @return map return struct: $["return": boolean, "err_msg": string]
     */
    define map SaveModulesEntry (list save_info, list system) ``{
	y2milestone("SaveModulesEntry: %1, %2", save_info, system);

	path mod		= .modprobe_sound;
	path mod_alias		= .modprobe_sound.alias;
	path mod_options	= .modprobe_sound.options;
	SaveModulesOptions(save_info);

	list als=[];

        string err_msg = "";
	if (SCR::Read(.target.size, "/etc/modprobe.d/sound") >=0 && contains(SCR::Dir(mod), "alias"))
	{
	    als = (list)SCR::Read(mod_alias);
	}

	// remove old entries
	removeOldEntries (als);

	// remove old hwconfig files
	RemoveHWConfig();

	if (size(save_info) >0)
	{
	    if (!Sound::use_alsa)
	    {
		if (Arch::sparc ())
		{
		    string modname = save_info[0, "module"]:"off";
		    SCR::Write(add (mod_alias, "sound"), "sound-slot-0");
		}
	    }
	}

        if ((contains (maplist (map entry, (list<map<string,any> >)save_info,
		``(SaveOneModulesEntry (entry))), false)))
        {
            // Error message
            err_msg = err_msg + Sound::STRINGS["SaveModuleEntry"]:"";
            return $["return": false, "err_msg": err_msg];
        }

	/* also this is not neccessary now... (?)
	if (size(save_info) > 0 && Sound::use_alsa)
	{

	    list oss_aliases = alsa_oss(size(save_info));
	    foreach(map a, (list<map<string,any> >)oss_aliases, ``{
		SCR::Write(add (mod_alias, a["alias"]:""), a["module"]:"");
	    });
	}
	*/
	SCR::Write(mod, nil);

	// now, when new configuration was succesfully written, we should remove
	// the old one from /etc/modprobe.conf...
	if (Sound::used_modprobe_conf)
	    RemoveOldConfiguration ();

        return $["return" : true, "err_msg" : ""];
    }

    /**
     * Save volume (for alsa it's alsactl store
     * @return boolean success/failure
     */
    define boolean SaveVolume () ``{
	return (boolean) SCR::Execute(.audio.alsa.store, 0, 0);
    }

    /**
     * saves rc values that are stored in map
     * @param rc map "variable" : "value", ....
     * @return string error string
     */
    define string SaveRCValues (map rc) ``{
	SCR::Write (.sysconfig.sound.LOAD_SEQUENCER, rc["LOAD_ALSA_SEQ"]:"no");
	return "";
    }


}
