/* ------------------------------------------------------------------------------
 * Copyright (c) 2008 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/PulseAudio.ycp
 * Package:	PulseAudio configuration
 * Summary:	Configuration of PulseAudio in desktop applications
 * Authors:	Ladislav Slez√°k <lslezak@novell.com>
 */

{

module "PulseAudio";
textdomain "sound";

import "Mode";
import "FileUtils";
import "Summary";

boolean pa_enabled = nil;
boolean modified = false;

// path to the configuration script
const string pa_setup_script = "/usr/bin/setup-pulseaudio";

global boolean Read()
{
    // reset the modification flag
    modified = false;

    if (FileUtils::Exists(pa_setup_script))
    {
	map out = (map)SCR::Execute(.target.bash_output, pa_setup_script + " --status");
	y2milestone("Read status: %1", out);

	pa_enabled = regexpmatch(out["stdout"]:"", "^enabled");

	y2milestone("PulseAudio is %1", pa_enabled ? "enabled" : "disabled");
    }
    else
    {
	y2warning("PulseAudio setup script %1 is not present!", pa_setup_script);
	return false;
    }

    return true;
}

global boolean Propose()
{
    if (pa_enabled != nil)
    {
	y2milestone("PA is configured, skipping proposal");
	return true;
    }

    y2milestone("Proposing PA status to enabled");

    pa_enabled = true;
    modified = true;

    y2milestone("PulseAudio enabled: %1", pa_enabled);
    return true;
}

global boolean Write()
{
    y2milestone("PulseAudio::Write(): pa_enabled: %1, modified: %2", pa_enabled, modified);

    if (pa_enabled != nil && modified)
    {
	// always write the sysconfig to ensure that the setting
	// is written regardless whether setup-pulseaudio is installed or not

	// check whether PULSEAUDIO_ENABLE is already defined
	boolean write_comment = SCR::Read(.sysconfig.sound.PULSEAUDIO_ENABLE) == nil;

	SCR::Write(.sysconfig.sound.PULSEAUDIO_ENABLE, pa_enabled ? "yes" : "no");

	if (write_comment)
	{
	    // TODO: add a reload command?
	    SCR::Write(.sysconfig.sound.PULSEAUDIO_ENABLE.comment, "\n## Path:\tHardware/Soundcard/PulseAudio\n## Description:\tPulseAudio configuration\n## Type:\tyesno\n# Enable or disable PulseAudio system\n#\n");
	}

	// flush the changes
	SCR::Write(.sysconfig.sound, nil);

	if (FileUtils::Exists(pa_setup_script))
	{
	    y2milestone("%1 PulseAudio support", pa_enabled ? "Enabling" : "Disabling");

	    map out = (map)SCR::Execute(.target.bash_output, pa_setup_script +
		(pa_enabled ? " --enable" : " --disable"));

	    y2milestone("Write status: %1", out);

	    // reset the modification flag
	    modified = false;
	}
	else
	{
	    y2warning("PulseAudio setup script %1 is not present, cannot configure applications", pa_setup_script);

	    // reset the modification flag
	    modified = false;

	    return true;
	}
    }
    else
    {
	y2error("PulseAudio is not configured, cannot save activate configuration");
	return false;
    }

    return true;
}

global string Summary()
{
    if (pa_enabled == nil)
    {
	return "";
    }

    list<string> retlist = [
	Summary::Device("PulseAudio",
		// part of a summary text (PulseAudio is disabled/enabled)
		(pa_enabled ? _("Enabled") : _("Disabled"))
	)];

    return Summary::DevicesList(retlist);
}

global void Reset()
{
    y2milestone("Resetting PulseAudio configuration");
    pa_enabled = nil;
    modified = false;
}

global map Export()
{
    if (pa_enabled == nil)
    {
	return $[];
    }

    return $[
	"pulse_audio_status" : pa_enabled
    ];
}

global boolean Import(map settings)
{
    if (haskey(settings, "pulse_audio_status"))
    {
	pa_enabled = settings["pulse_audio_status"]:false;
	modified = true;

	y2milestone("Imported PulseAudio configuration: pa_enabled: %1", pa_enabled);
    }
    else
    {
	y2milestone("The imported configuration doesn't contain PulseAudio configuration.");
	pa_enabled = nil;
    }

    return true;
}

global void Enable(boolean enable)
{
    if (enable == nil)
    {
	y2error("PulseAudio::Enable(): nil argument");
    }
    else
    {
	modified = enable != pa_enabled;
	pa_enabled = enable;
	y2milestone("Enabling PulseAudio support: %1", pa_enabled);

	if (modified)
	{
	    y2milestone("PulseAudio config has been changed");
	}
    }
}

global boolean Modified()
{
    return modified;
}

global boolean Enabled()
{
    return pa_enabled;
}

}
