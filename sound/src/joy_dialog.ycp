/**
 * File:	include/sound/joy_dialog.ycp
 * Package:	Joystick configuration
 * Summary:	Joystick dialogs
 * Authors:	Dan Meszaros <dmeszar@suse.cz>
 *		Ladislav Slezak <lslezak@suse.cz>
 *		Jiri Suchomel <jsuchome@suse.cz>
 */

{

    textdomain "sound";

    import "Wizard";
    import "WizardHW";
    import "Joystick";
    import "Sound";
    import "Package";
    import "Label";
    import "Popup";
    import "String";

    include "sound/joysticks.ycp";
    include "sound/ui.ycp";
    include "sound/volume_routines.ycp";
    include "sound/routines.ycp";

    // notice about USB devices, used at several places
    const string usb_notice = _("USB joysticks do not need any configuration, just connect them.");

    const string gameport = "Gameport";

/**
 * Update the sound card configuration of joystick
 * @param start	should joystick be used?
 * @return was sound config changed?
 */
define boolean update_sound_card_joy_config (integer card_id, boolean start) ``{

    map sound_options	= Sound::modules_conf[card_id, "options"]:$[];
    string modname	= Sound::modules_conf[card_id, "module"]:"";
    if (!haskey (Sound::joystick_configuration, modname))
    {
	return false;
    }
    map<string,string> joy_option = Sound::joystick_configuration[modname]:$[];
    string opname	= "";
    string value	= "0";
    // there should be only one entry
    foreach (string name, string val, joy_option, ``{
	opname		= name;
	value		= val;
    });
    string default_value	=
	Sound::db_modules [modname, "params", opname, "default"]:"0";

    if ((start && sound_options[opname]:default_value == default_value) ||
	(!start && sound_options[opname]:default_value != default_value))
    {
	sound_options[opname]	= start ? value : default_value;
	Sound::modules_conf[card_id, "options"]	= sound_options;
	return true;
    }
    return false;
}


    /*
     * Find index of the sound card in Sound::modules_conf
     * @param sound card map (as returned from .probe.sound)
     * @return integer index in Sound::modules_conf
     */
    integer find_sound_card_id(map sound_card)
    {
	integer i = 0;
	integer ret = nil;

	foreach(map card, Sound::modules_conf, {
	    if (card["unique_key"]:"" == sound_card["unique_key"]:"")
	    {
		ret = i;
	    }

	    i = i + 1;
	});

	return ret;
    }


    /**
     * Joystick configuration dialog.
     * Configuration of joystick attached to specified sound card.
     * @param joy_id Joystick index (in the sysconfig file)
     * @param button Label for `next button: `finish, `ok or `next
     * @return symbol Id of pressed button in the dialog
     */
    define symbol joy_dialog (integer joy_id, symbol button, map sound_card) ``{
	if (joy_id == nil)
	{
	    return `back;
	}

	// find card name
	string cardname = sound_card["model"]:"";

	// dialog header - %1: card name (e.g "Soundblaster 16")
	string caption = sformat(_("Joystick Configuration - %1"), cardname);

	string helptext =
	// help text for joystick configuration 1/4
_("<P>In this dialog, specify your joystick type. If your
joystick type is not in the list, select <B>Generic Analog Joystick</B>.</p>
<p>You will not find any USB joysticks here. If you have a USB device, just plug in the joystick and start using it.</P>
");

	map joy		= Joystick::joystick[joy_id]:$[];
	string mod	= joy["model"]:"";

	y2milestone("Joystick configuration started, index: %1", joy_id);

	// translate model from /etc/sysconfig/joystick
	if (mod == Joystick::generic_joystick)
	{
	    mod = Joystick::generic_joystick_translated;
	}

	// list of joystick drivers and models
	list joylist = maplist(string modname, list<string> models, JoystickDB, ``(
	    maplist(string model, models, ``([modname, model]))
	));
	joylist = flatten ((list<list>)joylist);

	joylist = sort (list j1, list j2, (list<list<any> >) joylist, ``( j1[1]:"" < j2[1]:""));

	joylist = prepend (joylist,
	    ["analog", Joystick::generic_joystick_translated]);

	y2debug("joylist: %1", joylist);

	integer index = 0;
	list boxitems = [];

	foreach (list l, (list<list<any> >) joylist, ``{

	    string model = l[1]:"";
	    if (mod == model)
	    {
		// preselect item
		boxitems = add(boxitems, `item(`id(index), model, true));
	    }
	    else
	    {
		boxitems = add(boxitems, `item(`id(index), model));
	    }
	    index = index + 1;
	});

	y2debug("for widget: %1", boxitems);

	term contents = `VBox(
	    `VSpacing(3),
	    `HBox(
		`HSpacing(3),
		// label above list of joystick types
		`SelectionBox(`id(`os), _("&Select your joystick type:"),
		    boxitems),
		`HSpacing(3)
	    ),
	    `VSpacing(3)
	);

	map nextbutton = $[
	    `finish	: Label::FinishButton(),
	    `ok		: Label::OKButton(),
	    `next	: Label::NextButton()
	];

	Wizard::OpenNextBackDialog();
	Wizard::SetContents (caption, contents, helptext, true, true);
	Wizard::SetNextButton(`next, nextbutton[button]:Label::NextButton() );
	if (!Mode::installation()) Wizard::HideBackButton();

	symbol s = nil;
	do
	{
	    s = (symbol) UI::UserInput();

	    if (s == `abort && !ReallyAbort())
	    {
		s = `skip_event;
	    }

	    if (s == `next && UI::QueryWidget(`id(`os), `CurrentItem) == nil)
	    {
		// warning message - user did not select any joystick type
		Popup::Warning(_("Select the joystick type from the list
before pressing Next.

"));
		s = `skip;
	    }
	} while (!contains([`next, `back, `abort, `cancel], s));

	if (s == `next)
	{
	    integer card_id = find_sound_card_id(sound_card);
	    string modname	= Sound::modules_conf[card_id, "module"]:"";
	    map joy_entry	= Sound::GetJoystickSettings (modname);
	    integer joymodidx = (integer)UI::QueryWidget(`id(`os),`CurrentItem);
	    string joymod	= joylist[joymodidx,0]:"";

	    if (joymod == "")
	    {
		// selected none joystick
		joy_entry = $[];
	    }
	    else
	    {
		string model = joylist[joymodidx, 1]:"";

		// do not translate model in /etc/sysconfig/joystick
		if (model == Joystick::generic_joystick_translated)
		{
		    model = Joystick::generic_joystick;
		}

		y2debug("selected joy module: %1, model: %2", joymod, model);

		joy_entry["JOYSTICK_MODULE"] = joymod;
		joy_entry["model"] = model;
		joy_entry["attached_to"] = sound_card["unique_key"]:"";
	    }
	    update_sound_card_joy_config (card_id, joymod != "");

	    Joystick::joystick[joy_id] = joy_entry;
	    Joystick::modified = true;

	    y2milestone("New joystick configuration: %1", joy_entry);
	}

	// restore previous `next button label (only if label was not Finish)
	if (button != `finish)
	{
	    Wizard::RestoreNextButton();
	}

	if (!Mode::installation()) Wizard::RestoreBackButton();
	Wizard::CloseDialog();

	return s;
    }

    /*
     * Create unique widget id for a broken joystick config
     * @param index index of non-working joystick configuration
     * @return string the ID
     */
    define string broken_id(integer index)
    {
	return sformat("broken_%1", index);
    }

    /*
     * Belogs the ID to a broken joystick?
     * @param id
     * @return boolean true if the ID belongs to a broken configuration
     */
    define boolean is_broken(string id)
    {
	return regexpmatch(id, "broken_[0-9]+");
    }

    /*
     * Get the joystick index from broken ID string
     * @param id
     * @return integer the ID or nil if the ID do not belong to a broken configuration
     */
    define integer broken_index(string id)
    {
	string num = regexpsub(id, "broken_([0-9]+)", "\\1");

	if (num == nil)
	{
	    return nil;
	}

	return tointeger(num);
    }

    /*
     * Get details about the joustick bus
     * @param js Joystick device map
     * @param soundcards List of detected soundcards
     * @return string Bus description
     */
    string joystick_bus_details(map js, list<map> soundcards)
    {
	string ret = js["bus"]:"";

	if (ret == gameport)
	{
	    string unique_key = js["parent_unique_key"]:"";

	    map card = find(map c, soundcards, {return c["unique_key"]:"" == unique_key;});

	    if (card != nil)
	    {
		// joystick details, %1 is the sound card name to which is the joystick connected
		ret = sformat(_("%1 (%2)"), ret, card["model"]:"");
	    }
	}

	return ret;
    }

    /*
     * Create content for the joystick overview table
     * @return list<map<string,any>> content for WizardHW::SetContents() function 
     */
    define list<map<string,any> > joystick_table()
    {
	list<map<string,any> > content = [];
	list<map> soundcards = (list<map>)SCR::Read(.probe.sound);
	list<integer> found_joysticks = [];

	foreach(map js, Joystick::Detected(),
	{
	    y2milestone("Adding joystick to table: %1", js);
	    string device = js["dev_name2"]:"";
	    string model = js["model"]:"";
	    list<string> descr = [];

	    if (js["detail","axes"]:0 > 0)
	    {
		descr = add(descr, sformat(_("Number of axes: %1"), js["detail","axes"]:0));
	    }

	    if (js["detail","buttons"]:0 > 0)
	    {
		descr = add(descr, sformat(_("Number of buttons: %1"), js["detail","buttons"]:0));
	    }

	    string bus = js["bus"]:"";

	    // add the sound card name for gameport joysticks
	    if (bus == gameport && size(js["parent_unique_key"]:"") > 0)
	    {
		bus = joystick_bus_details(js, soundcards);
		string unique_key = js["parent_unique_key"]:"";

		integer i = 0;
		integer joy_index = nil;

		while(i < 4)
		{
		    map jconf = Joystick::joystick[i]:$[];

		    if (jconf["attached_to"]:"" == unique_key)
		    {
			joy_index = i;
			break;
		    }

		    i = i + 1;
		}

		if (joy_index != nil)
		{
		    map j_config = find(map j, (list<map>)Joystick::joystick, {return j["attached_to"]:"" == unique_key;});
		    string config_model = j_config["model"]:"";

		    if (config_model != nil && config_model != "")
		    {
			y2milestone("Adding joystick model: %1", config_model);

			model = sformat("%1 (%2)", model, config_model);
		    }

		    found_joysticks = add(found_joysticks, joy_index);
		}
	    }

	    map<string,any> j = $[
		"id" : device,
		"table_descr" : [ model, device, bus ],
		"rich_descr" : WizardHW::CreateRichTextDescription(model, descr)
	    ];

	    content = add(content, j);
	});

	y2milestone("Found joysticks at indices: %1", found_joysticks);

	integer i = 0;
	// check non-working joystick configurations
	foreach(map js, (list<map>)Joystick::joystick, {
	    if (!contains(found_joysticks, i) && js["JOYSTICK_MODULE"]:"" != "")
	    {
		y2milestone("Found inactive joystick configuration at index %1: %2", i, js);
		string model = js["model"]:_("Unknown joystick model");
		string unique_key = js["attached_to"]:"";
		string bus = gameport;

		map card = find(map c, soundcards, {return c["unique_key"]:"" == unique_key;});

		if (card != nil)
		{
		    // joystick details, %1 is the sound card name to which is the joystick connected
		    bus = sformat("%1 (%2)", bus, card["model"]:"");
		}

		map<string,any> j = $[
		    "id" : broken_id(i),
		    // the joystick device was not found (the joystick is probably disconnected)
		    "table_descr" : [ model, _("<not found>"), bus ],
		    // add red warning about invalid configuration to the model name (%1)
		    "rich_descr" : WizardHW::CreateRichTextDescription(sformat(_("%1 - <font color=\"red\">Invalid configuration<font>"), model), [
			// help text
			_("The configuration is not active - either the joystick is not connected or a wrong driver is used"),
			// help text
			_("Press <b>Edit</b> to change the joystick driver or <b>Delete</b> to remove the configuration")
		    ])
		];

		content = add(content, j);
	    }

	    i = i + 1;
	});

	return content;
    }

    /*
     * Find detected joystick with requested device name
     * @param device joystick device name (e.g. "/dev/input/js0")
     * @return map joystick map returned from .probe.joystick agent
     */
    map find_joystick(string device)
    {
	return find(map j, Joystick::Detected(), {return j["dev_name2"]:"" == device;});
    }

    /*
     * Display and run the joystick test dialog
     * @param device device name of the joystick to test (e.g. "/dev/input/js0")
     */
    void test_joystick(string device)
    {
	map js = find_joystick(device);
	if (js == nil)
	{
	    y2error("Cannot find joystick %1", device);
	    return;
	}

	// generate appropriate dialog for the joystick
	term joy_attrib	= `VBox();
	integer min		= -32767; // see js_event.value in linux/joystick.h
	integer max		= 32767;
	integer i = 0;

	while (i < js["detail","axes"]:0)
	{
	    // progress bar label
	    string widget_name	= sformat(_("Axis %1"), i);
	    string widget_id	= sformat("Axis %1", i);

	    if (UI::HasSpecialWidget(`Slider))
	    {
		joy_attrib  = add(joy_attrib, `Slider(`id(widget_id), `opt(`disabled), widget_name, min, max, 0));
	    }
	    else
	    {
		joy_attrib  = add(joy_attrib, `IntField(`id(widget_id), `opt(`disabled), widget_name, min, max, 0));
	    }

	    joy_attrib	= add(joy_attrib, `VSpacing(0.3));
	    i = i + 1;
	}

	term joy_buttons	= `HBox();
	string not_pressed	= "    ";
	string pressed	= UI::Glyph(`CheckMark);

	i = 0;
	while (i < js["detail","buttons"]:0)
	{
	    // label
	    string widget_name	= sformat(_("Button %1"), i);
	    string widget_id	= sformat ("Button %1", i);
	    joy_buttons	= add (joy_buttons,
		`Label (`id(widget_id), widget_name + " " + not_pressed));
	    joy_buttons	= add (joy_buttons, `HSpacing(2));
	    i = i + 1;
	}
	joy_attrib = add (joy_attrib, joy_buttons);

	UI::OpenDialog(`opt(`decorated), `HBox(`HSpacing(1.5),
	    `VSpacing(18),
	    `VBox(
		`HSpacing(50),
		`VSpacing(0.5),
		// Popup label
		`Heading(_("Joystick Test")),
		`VSpacing(0.5),
		// label - joystick details (%1 is model name, %2 is bus name)
		`Left(`Label(sformat(_("Joystick: %1, attached to: %2"), js["model"]:"",
		    joystick_bus_details(js, (list<map>)SCR::Read(.probe.sound)))
		)),
		//`VSpacing(0.5),
		joy_attrib,
		`VSpacing(1),
		`PushButton(`id(`done), `opt(`default), Label::OKButton()),
		`VSpacing(1)
	    ),
	    `HSpacing(1.5)
	));

	string command = sformat("/usr/bin/jstest --event '%1'", String::Quote(device));
	integer process = (integer)SCR::Execute(.process.start_shell, command);

	symbol ret = nil;

	// read the jstest output until "OK" button is pushed
	do
	{
	    if (SCR::Read(.process.running, process) == false)
	    {
		y2error("Unexpected exit");
		break;
	    }

	    string out = (string)SCR::Read(.process.read_line, process);

	    if (out != nil)
	    {
		y2debug("jstest output: %1", out);

		// the output is like "Event: type 2, time 26263500, number 0, value 0"
		string type_str = regexpsub(out, "type ([0-9]+)", "\\1");
		string number_str = regexpsub(out, "number ([0-9]+)", "\\1");
		string value_str = regexpsub(out, "value ([-]{0,1}[0-9]+)", "\\1");

		if (type_str != nil && number_str != nil && value_str != nil)
		{
		    integer type = tointeger(type_str);
		    integer number = tointeger(number_str);
		    integer value = tointeger(value_str);

		    if (type == 1)
		    {
			// button state changed
			UI::ChangeWidget(`id(sformat("Button %1", number)), `Value,
			    // label text ("Button" is joystick's button no. %1)
			    sformat(_("Button %1"), number) + " " + (value == 1 ? pressed : not_pressed));
		    }
		    else if (type == 2)
		    {
			// change in some axis
			UI::ChangeWidget(`id(sformat ("Axis %1", number)), `Value, value) ;
		    }
		}
	    }
	    ret = (symbol)UI::PollInput();
	}
	while (ret == nil);

	y2milestone ("killing");
	SCR::Execute(.process.kill, process);

	// release the process from the agent
	SCR::Execute(.process.release, process);

	UI::CloseDialog();
    }

    /*
     * Return list of sound cards with gameport that do not have any joystick configured
     * @param gameport_cards list of all cards with gameport
     * @return list list of cards from gameport_cards that don't have any joystick configured
     */
    list unconfigured_sound_cards(list gameport_cards)
    {
	list ret = filter(map card, (list<map>) gameport_cards, {
	    return find(map j, (list<map>)Joystick::joystick, {return j["attached_to"]:"" == card["unique_key"]:"";}) == nil;
	});

	y2milestone("Unconfigured gameport cards: %1", ret);
	return ret;
    }

    /*
     * Display dialog for selecting sound card to configure
     * @param gameport_cards available sound cards with gameport
     * @returen map the selected card (one from gameport_cards) or nil if [Cancel] was pressed
     */
    map select_sound_card(list gameport_cards)
    {
	integer i = -1;
	list tcont = maplist (map card, (list<map>) gameport_cards, {
	    i = i + 1;
	    return `item(
	       `id(i),
	       card["model"]:"Sound card"
	    );
	});

	term dialog = `HBox(
	    `VSpacing(10),
	    `VBox(
		`Heading(_("Sound Cards with Joystick Support")),
		`Table(`id(`cards), `header(
			// table header (card name)
			_("Sound card")
		    ),
		    tcont
		),
		`Label(_("To add an USB joystick close this dialog and just connect it.")),
		`ButtonBox(
		    // button label
		    `PushButton(`id(`ok), _("&Configure joystick")),
		    `PushButton(`id(`cancel), Label::CancelButton())
		)
	    )
	);

	UI::OpenDialog(`opt(`decorated), dialog);

	// preselect the first card
	UI::ChangeWidget(`id(`cards), `CurrentItem, 0);

	symbol ret = (symbol) UI::UserInput();

	integer joy_card = (integer) UI::QueryWidget(`id(`cards), `CurrentItem);
	y2milestone("Selected sound card: %1", joy_card);

	UI::CloseDialog();

	if (ret == `cancel || ret == `abort) {
	    y2milestone("Sound card selection canceled");
	    return nil;
	}

	return gameport_cards[joy_card]:$[];
    }

    /*
     * Is the selected joystick connected via USB?
     * @param device joystick device name (e.g. "/dev/input/js0")
     * @reurn boolean true if the device is an USB joystick
     */
    boolean is_usb(string device)
    {
	map js = find_joystick(device);
	if (js == nil) return false;

	return js["bus"]:"" == "USB";
    }

    /*
     * Find joystick index which is attached to a sound card
     * @param parent_id the unique key of the sound card
     * @return the index or nil if the sound card was not found
     */
    integer find_joystick_number(string parent_id)
    {
	integer i = 0;
	boolean found = false;

	foreach(map j, (list<map>)Joystick::joystick, {
	    if (j["attached_to"]:"" == parent_id)
	    {
		found = true;
		break;
	    }
	    i = i + 1;
	});

	integer ret = i;

	if (!found)
	{
	    ret = nil;
	}
	y2milestone("Joystick index with parent id %1: %2", parent_id, ret);

	return ret;
    }

    /*
     * Find the index of the first unused joystick configuration
     * @return integer the index or nil when all configs are already used
     */
    integer find_free_number()
    {
	integer i = 0;
	boolean found = false;

	foreach(map j, (list<map>)Joystick::joystick, {
	    if (j["JOYSTICK_MODULE"]:"" == "")
	    {
		found = true;
		break;
	    }
	    i = i + 1;
	});

	integer ret = i;

	if (!found)
	{
	    ret = nil;
	}
	y2milestone("Unconfigured joystick at index: %1", ret);

	return ret;
    }

    /*
     * Save one joystick configuration and restart the joystick service to reload drivers
     * @param num index of the joystick configuration to change
     */
    define void restart_joystick(integer num)
    {
	// restart joystick service to reload the driver
	Joystick::Stop();
	Joystick::SaveOneJoystick(num);
	Joystick::WriteConfig();
	Joystick::StartAndEnable();

	// re-detect attached joysticks
	Joystick::Detect();
    }

    /*
     * Refresh the joystick table in the main configuration dialog
     */
    define void refresh_table()
    {
	list<map<string,any> > items = joystick_table();
	WizardHW::SetContents(items);
    }

    /*
     * Return the list of detected sound cards that support gameport
     * @return list<map> list of devices (as returned by .probe.sound agent)
     */
    list<map> sound_cards_with_joystick()
    {
	list<map> sound_cards = (list<map>)SCR::Read(.probe.sound);

	sound_cards = filter(map sound_card, sound_cards, {
	    string driver = get_module(sound_card)["name"]:"";

	    if (driver == nil || driver == "")
	    {
		driver = String::Replace(sound_card["driver_module"]:"", "_", "-");
	    }

	    return Sound::db_modules[driver, "joystick"]:$[] != $[];
	});

	return sound_cards;
    }

    /*
     * Return modification time of /dev/input directory
     * @return integer mtime in seconds
     */
    integer input_mtime()
    {
	return ((map)SCR::Read(.target.stat, "/dev/input"))["mtime"]:0;
    }

    /*
     * Display and run the main joystick dialog
     * @return symbol the final user input
     */
    define symbol joystick_overview()
    {
	list<list> extra_buttons = [
	    // menu item
	    [`test, _("&Test selected joystick...")],
	];

	// dialog title
	WizardHW::CreateHWDialog(_("Joysticks"),
	    // help text
	    _("<p><big><b>Joysticks</b></big></p>")
	    + _("<p>Here is an overview of the detected joysticks.</p>")
	    + _("<p>To configure a new joystick connected to a Gameport press <b>Add</b> button.</p>")
	    + "<p>" + usb_notice + "</p>",
	    // table header
	    [_("Model"), _("Device name"), _("Attached to")],
	    extra_buttons
	);

	// create description for WizardHW
	list<map<string,any> > items = joystick_table();
	y2debug("items: %1", items);

	WizardHW::SetContents(items);

	Wizard::SetNextButton(`next, Label::FinishButton());

	symbol ret = `dummy;
	integer mtime = input_mtime();

        while (!contains([`abort, `back, `next],ret))
	{
	    ret = (symbol)UI::TimeoutUserInput(2000);

	    // no user input, check for hotplug changes
	    if (ret == `timeout)
	    {
		integer current_mtime = input_mtime();

		if (current_mtime != mtime)
		{
		    // /dev/input has changed - rescan joysticks and refresh the table
		    y2milestone("/dev/input has been changed, rescanning devices...");

		    Joystick::Detect();
		    refresh_table();

		    mtime = current_mtime;
		}

		continue;
	    }

	    if (ret == `cancel) ret = `abort;

	    string device = WizardHW::SelectedItem();

	    if (ret == `add)
	    {
		list<map> jcards = sound_cards_with_joystick();
		y2milestone("Sound cards with gameport: %1", jcards);

		// no sound card with gameport
		if (size(jcards) == 0)
		{
		    string message = _("There is no soundcard with joystick support (gameport).")
			+ "\n" + usb_notice;

		    Popup::Message(message);
		}
		else
		{
		    // remove configured cards with joystick
		    list unconfigured = unconfigured_sound_cards(jcards);
		    y2milestone("Gamport sound cards without joystick: %1", unconfigured);

		    if (size(unconfigured) == 0)
		    {
			string message = _("There is no soundcard with unconfigured joystick.")
			    + "\n" + usb_notice;

			Popup::Message(message);
		    }
		    else
		    {
			// if there is just one card just use it otherwise ask user
			map card = (size(unconfigured) == 1) ? unconfigured[0]:$[] : select_sound_card(unconfigured);
			integer joy_index = find_free_number();

			// selection canceled?
			if (card != nil)
			{
			    joy_dialog(joy_index, `ok, card);

			    restart_joystick(joy_index);

			    refresh_table();
			}
		    }
		}
	    }
	    else if (ret == `edit)
	    {
		if (is_usb(device))
		{
		    // popup message - pressed [Edit] when an USB joystick is selected
		    Popup::Message("USB joysticks do not need any configuration.");
		}
		else
		{
		    integer num = nil;
		    string key = "";

		    if (is_broken(device))
		    {
			num = broken_index(device);
			map j = Joystick::joystick[num]:$[];
			key = j["attached_to"]:"";
		    }
		    else
		    {
			key = find_joystick(device)["parent_unique_key"]:"";
			num = find_joystick_number(key);
		    }

		    list<map> soundcards = (list<map>)SCR::Read(.probe.sound);
		    map card = find(map c, soundcards, {return c["unique_key"]:"" == key;});
		    symbol ui = joy_dialog(num, `ok, card);

		    if (ui == `next || ui == `finish)
		    {
			// restart joystick service to reload the driver
			restart_joystick(num);

			// refresh table content
			refresh_table();
		    }
		}
	    }
	    else if (ret == `delete)
	    {
		if (is_usb(device))
		{
		    // popup message - pressed [Delete] when an USB joystick is selected
		    Popup::Message("USB joysticks cannot be deleted, just unplug them.");
		}
		else
		{
		    integer num = is_broken(device) ? broken_index(device)
			: find_joystick_number(find_joystick(device)["parent_unique_key"]:"");

		    y2milestone("Deleting joystick %1 (index %2)", device, num);

		    // modify joystick config
		    Joystick::joystick[num] = $[];
		    Joystick::modified = true;

		    // restart joystick service to reload the driver
		    restart_joystick(num);

		    // refresh table content
		    refresh_table();
		}
	    }
	    else if (ret == `test)
	    {
		if (is_broken(device))
		{
		    // error popup
		    Popup::Error(_("The selected joystick configuration is not active.\n\nThe joystick cannot be tested."));
		}
		else
		{
		    test_joystick(device);
		}
	    }
	}

	y2milestone("Final joystick config: %1", Joystick::joystick);
	y2milestone("Joystick overview result: %1", ret);

	return ret;
    }

/* EOF */
}
