/**
 * File:
 *   sound_complex
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   sound complex dialog
 *
 * Authors:
 * Dan Vesely <dan@suse.cz>
 * Dan Meszaros <dmeszar@suse.cz>
 * Ladislav Slezak <lslezak@suse.cz>
 *
 * String corrections by Christian Steinruecken <cstein@suse.de>, 2001/08/01
 *
 *
 */

{

    textdomain "sound";

    import "Wizard";
    import "Label";
    import "Popup";
    import "Mode";
    import "WizardHW";
    import "Report";
    import "PulseAudio";

    import "Sound";
    include "sound/mixer.ycp";
    include "sound/options.ycp"; // sound_options
    include "sound/volume.ycp";  // VolumeDialog
    include "sound/volume_routines.ycp"; // PlayTest()

    /**
     * creates summary table with card labels and thier states
     * (running/not running/dissappeared)
     * @return list table contents
     */
    define list<map<string,any> > createHWTable() ``{

	y2milestone("unconfigured_cards: %1", Sound::unconfigured_cards);
	y2milestone("modules_conf: %1", Sound::modules_conf);

	list<map<string,any> > ret = [];

	if (Sound::modules_conf != nil && size(Sound::modules_conf) > 0)
	{
	    foreach(map card, Sound::modules_conf, {
		    list<string> descr = [];

		    if (card["options","index"]:"" != nil)
		    {
			descr = add(descr, sformat(_("Configured as sound card number %1"), card["options","index"]:""));
		    }

		    if (card["module"]:nil != nil)
		    {
			descr = add(descr, sformat(_("Driver %1"), card["module"]:""));
		    }

		    string pkgs = Sound::RequiredPackagesToInstallSummary(card["module"]:"");

		    if (size(pkgs) > 0)
		    {
			descr = add(descr, pkgs);
		    }

		    map<string,any> r = $[
			"id" : card["unique_key"]:"",
			"table_descr" : [ card["options","index"]:"", card["model"]:"" ],
			"rich_descr" : WizardHW::CreateRichTextDescription(card["model"]:"", descr)
		    ];

		    ret = add(ret, r);
		}
	    );
	}

	// sort the cards by index
	ret = sort(map<string,any> card1, map<string,any> card2, ret, {return tointeger(card1["table_descr", 0]:"0") < tointeger(card2["table_descr", 0]:"0");});

	if (Sound::unconfigured_cards != nil && size(Sound::unconfigured_cards) > 0)
	{
	    foreach(map card, Sound::unconfigured_cards, {
		    list<string> descr = [];

		    if (card["module"]:nil != nil)
		    {
			descr = add(descr, sformat(_("Driver %1"), card["module"]:""));
		    }

		    map<string,any> r = $[
			"id" : card["unique_key"]:"",
			"table_descr" : [ _("Not configured"), card["model"]:"" ],
			"rich_descr" : WizardHW::CreateRichTextDescription(card["model"]:"", WizardHW::UnconfiguredDevice())
		    ];

		    ret = add(ret, r);
		}
	    );
	}

	y2debug("table content: %1", ret);

	return ret;
    }

    define integer getCardIndex(list<map<string, any> > scards, string uniq) {
	integer ret = nil;

	if (scards != nil)
	{
	    foreach(map<string, any> scard, scards, {
		    if (scard["unique_key"]:nil == uniq)
		    {
			if (scard["options", "index"]:nil != nil)
			{
			    ret = tointeger(scard["options", "index"]:nil);
			}
		    }
		}
	    );
	}

	y2debug("found at index: %1", ret);

	return ret;
    }

    define integer getCardIndex2(list<map<string, any> > scards, string uniq) {
	integer ret = nil;

	if (scards != nil)
	{
	    integer i = 0;
	    foreach(map<string, any> scard, scards, {
		    if (scard["unique_key"]:nil == uniq)
		    {
			ret = i;
		    }

		    i = i + 1;
		}
	    );
	}

	y2debug("found at index: %1", ret);

	return ret;
    }

    /**
     * function for enabling relevant controls in complex dialog
     * @param val boolean enable/disable
     */

    define void enableButtons(boolean val) ``{
	UI::ChangeWidget(`id(`b_delete),    `Enabled, val);
        UI::ChangeWidget(`id(`b_options),   `Enabled, val);
	UI::ChangeWidget(`id(`b_volume),    `Enabled, val);
    }

    string selected_card = "";

define void SetItems() {
    // create description for WizardHW
    list<map<string,any> > items = createHWTable();
    y2debug("items: %1", items);

    WizardHW::SetContents(items);
}

define symbol Mixer()
{
    symbol ret = nil;
    map res = $[];

    if (Mode::config())
    {
	symbol dialog_result = VolumeDialog(Sound::modules_conf[Sound::card_id]:$[], true, Sound::card_id);

	res["ui"] = dialog_result;
    }
    else
    {
	res =  mixerDialog(Sound::card_id);
    }

    ret = (symbol)res["ui"]:nil;

    if (ret == `cancel)
    {
	ret = `abort;
    }

    return ret;
}

define symbol EditConfigured()
{
    symbol ret = nil;
    integer idx_conf = getCardIndex((list<map<string,any> >)Sound::modules_conf, Sound::selected_uniq);
    integer idx_list = getCardIndex2((list<map<string,any> >)Sound::modules_conf, Sound::selected_uniq);

    // the card is already configured
    if (idx_conf != nil && idx_list != nil)
    {
	y2milestone("Configuring card %1", Sound::selected_uniq);
	map entry = Sound::modules_conf[idx_list]:$[];
	map oldentry = entry;

	do
	{
	    map res = sound_options(entry);
	    if (res["ui"]:nil == `next)
	    {
		entry = res["return"]:$[];
		entry = add_common_options(entry, idx_conf);

		// update card data
		Sound::modules_conf = maplist(map card, Sound::modules_conf,
		    {
			if (card["unique_key"]:"" != Sound::selected_uniq)
			{
			    return card;
			}
			else
			{
			    return entry;
			}
		    }
		);

		y2milestone("updated config: %1", Sound::modules_conf);

		if (oldentry != entry)
		{
		    // popup question text
		    if (Popup::YesNo(_("To apply changes, the sound system
must be restarted.
Restart sound system now?
")))
		    {
			y2milestone("Restarting sound system...");
			sound_stop();
			boolean started = sound_start_tmp(true);
			y2milestone("... restart done: %1", started);

			if (!started)
			{
			    Report::Error(_("Restart of the sound system has failed.
Check options of the driver.
"));
			    ret = `again;
			    continue;
			}
		    }
		}
		ret = `next;
	    }
	    else if (res["ui"]:nil == `abort || res["ui"]:nil == `cancel)
	    {
		ret = `abort;
	    }
	    else
	    {
		ret = (symbol)res["ui"]:nil;
	    }
	}
	while (ret == `again);
    }

    return ret;
}

define symbol Edit()
{
    symbol ret = nil;
    integer idx_conf = getCardIndex2((list<map<string,any> >)Sound::modules_conf, Sound::selected_uniq);
    integer idx_det = getCardIndex2((list<map<string,any> >)Sound::unconfigured_cards, Sound::selected_uniq);

    y2milestone("uniq (%1) in configured: %2, in detected: %3", Sound::selected_uniq, idx_conf, idx_det);

    // the card is already configured
    if (idx_conf != nil)
    {
	y2milestone("reconfiguring card %1", Sound::selected_uniq);
	Sound::card_id = idx_conf;
	ret = `edit_conf;
    }
    else if (idx_det != nil)
    {
	y2milestone("adding new card %1", Sound::selected_uniq);
	Sound::card_id = idx_det;
	ret = `edit_new;
    }
    else
    {
	y2error("card %1 was not found!", Sound::selected_uniq);
	ret = `not_found;
    }

    return ret;
}

void PulseAudioPopup()
{
    if (!Mode::config() && PulseAudio::Enabled() == nil)
    {
	y2error("PulseAudio status is nil - the setup script is missing?");
	// error popup message
	Popup::Error(_("PulseAudio is not installed or cannot be configured."));
	return;
    }

    term dlg =
    `HBox(
	`HSpacing(1),
	`VBox(
	    `VSpacing(0.5),
	    // frame label
	    `Frame(_("PulseAudio Configuration"),
		`VBox(
		    `VSpacing(0.5),
		    `Left(`CheckBox(`id(`pulseaudio),
			// check box label
			_("&Enable PulseAudio Support"), PulseAudio::Enabled() == true)
		    ),
		    `VSpacing(0.5)
		)
	    ),
	    `VSpacing(`opt(`vstretch), 1),
	    `ButtonBox(
		`PushButton(`id(`ok), `opt(`default, `key_F10), Label::OKButton()),
		`PushButton(`id(`cancel), `opt(`key_F9), Label::CancelButton())
	    ),
	    `VSpacing(0.5)
	),
	`HSpacing(1)
    );

    UI::OpenDialog(`opt(`decorated), dlg);

    symbol ui = (symbol)UI::UserInput();

    if (ui == `ok)
    {
	// get the current value
	boolean value = (boolean)UI::QueryWidget(`id(`pulseaudio), `Value);

	// set the value
	PulseAudio::Enable(value);
    }

    UI::CloseDialog();
}

define void SequencerPopup() {
    term dlg =
    `HBox(
	`HSpacing(1),
	`VBox(
	    `VSpacing(0.5),
	    // frame label
	    `Frame(_("Advanced Options"),
		`VBox(
		    `VSpacing(0.5),
		    `Left(`CheckBox(`id(`sequencer),
			// check box label
			_("&Start Sequencer (Load MIDI Drivers)"), Sound::rc_vars["LOAD_ALSA_SEQ"]:"no" == "yes")
		    ),
		    `VSpacing(0.5)
		)
	    ),
	    `VSpacing(`opt(`vstretch), 1),
	    `ButtonBox(
		`PushButton(`id(`ok), `opt(`default, `key_F10), Label::OKButton()),
		`PushButton(`id(`cancel), `opt(`key_F9), Label::CancelButton())
	    ),
	    `VSpacing(0.5)
	),
	`HSpacing(1)
    );

    UI::OpenDialog(`opt(`decorated), dlg);

    symbol ui = (symbol)UI::UserInput();

    if (ui == `ok)
    {
	// get current value
	string value = ((boolean)UI::QueryWidget(`id(`sequencer), `Value)) ? "yes" : "no";

	// set the value
	Sound::rc_vars = add(Sound::rc_vars, "LOAD_ALSA_SEQ", value);
    }

    UI::CloseDialog();
}

/**
 * Configure the selected sound card as the primary (default) card.
 * @param card_index index of the selected card in the internal structure
 * @param alsa_index index of the selected card in ALSA
*/
void SetPrimaryCard(integer card_index, integer alsa_index)
{
    y2milestone("Setting card %1 (snd-card-%2) as the primary card", card_index, alsa_index);
    y2debug("Before configuration: %1", Sound::modules_conf);

    integer index = 0;
    Sound::modules_conf = maplist(map sound_card, Sound::modules_conf,
	{
	    // the new primary sound_card
	    if (index == card_index)
	    {
		sound_card["options", "index"] = "0";
		sound_card["alias"] = "snd-card-0";
		y2milestone("New primary card: %1", sound_card);
	    }
	    // the old primary sound_card
	    else if (sound_card["options", "index"]:"" == "0")
	    {
		sound_card["options", "index"] = tostring(alsa_index);
		sound_card["alias"] = sformat("snd-card-%1", alsa_index);
		y2milestone("Previous primary card: %1", sound_card);
	    }

	    index = index + 1;

	    return sound_card;
	}
    );

    y2debug("After configuration: %1", Sound::modules_conf);
}

/**
 * A dialog showing the detected cards and allowing to configure them.
 * @return any The value of the resulting UserInput.
 */
define map HardwareDialog() {

    boolean show_fonts = false;
    maplist(map card, Sound::modules_conf, ``{
	if (HasFonts(card)) show_fonts = true;
    });

    list<list> extra_buttons = [
	// menu item
	[`mixer, _("&Volume...")],
	// menu item
	[`play_test, _("Play &Test Sound")],
	// menu item
	[`seq, _("&Start Sequencer")],
	// menu item
	[`primary, _("Set as the &Primary Card")],
	// menu item
	[`pulseaudio, _("PulseAudio &Configuration...")],
    ];

    if (show_fonts)
    {
	// menu item, do not translate "SoundFont" term (see http://en.wikipedia.org/wiki/Sound_font)
	extra_buttons = add(extra_buttons, [ `fonts, _("&Install SoundFonts...") ]);
    }

    // dialog title
    WizardHW::CreateHWDialog(_("Sound Configuration"),
	Sound::STRINGS["ComplexDialog"]:"",
	// table header
	[_("Index"), _("Card Model")],
	extra_buttons
    );

    Wizard::SetNextButton(`next, Label::OKButton());
    Wizard::SetAbortButton(`abort, Label::CancelButton());
    if (!Mode::installation()) Wizard::HideBackButton();

    symbol ret = `_dummy;

    do {
	SetItems();

	// initialize selected_card
	if (selected_card == "")
	{
	    selected_card = WizardHW::SelectedItem();
	}

	// set previously selected card
	WizardHW::SetSelectedItem(selected_card);

	map<string,any> ev = WizardHW::WaitForEvent();
	y2milestone("WaitForEvent: %1", ev);

	symbol ui = (symbol)ev["event","ID"]:nil;

	// remember the selected card
	selected_card = ev["selected"]:"";

	if (ui == `add)
	{
	    ret = `add;
	}
	else if (ui == `cancel || ui == `abort)
	{
	    if (ReallyAbort())
	    {
		ret = `abort;
		break;
	    }
	    else
	    {
		ui = `skip_event;
	    }
	}
	else if (ui == `delete)
	{
	    string uniq = WizardHW::SelectedItem();
	    integer idx = getCardIndex2((list<map<string,any> >)Sound::modules_conf, uniq);
	    y2milestone("Sound card index: %1", idx);

	    if (idx != nil)
	    {
		Sound::card_id = idx;
		ret = `delete;
	    }
	}
	else if (ui == `edit)
	{
	    Sound::selected_uniq = WizardHW::SelectedItem();
	    ret = `edit;
	}
	else if (ui == `mixer)
	{
	    string uniq = WizardHW::SelectedItem();
	    integer idx = getCardIndex((list<map<string,any> >)Sound::modules_conf, uniq);

	    if (idx != nil)
	    {
		Sound::card_id = idx;
		ret = `mixer;
	    }
	}
	else if (ui == `fonts)
	{
	    InstallFonts("", true);
	}
	else if (ui == `seq)
	{
	    SequencerPopup();
	}
	// configure the current card as primary
	else if (ui == `primary)
	{
	    string uniq = WizardHW::SelectedItem();
	    // sound card index
	    integer idx = getCardIndex2((list<map<string,any> >)Sound::modules_conf, uniq);
	    // alsa index (snd-card-X)
	    integer idx2= getCardIndex((list<map<string,any> >)Sound::modules_conf, uniq);

	    if (idx != nil && idx2 != 0)
	    {
		// set the primary card
		SetPrimaryCard(idx, idx2);
	    }
	}
	else if (ui == `pulseaudio)
	{
	    PulseAudioPopup();
	}
	else if (ui == `play_test)
	{
	    string uniq = WizardHW::SelectedItem();
	    // alsa index (snd-card-X)
	    integer card_id = getCardIndex((list<map<string,any> >)Sound::modules_conf, uniq);

	    if (card_id != nil && card_id >= 0)
	    {
		y2milestone("Playing test: card: %1", card_id);
		string msg = PlayTest(card_id);

		if (msg != "")
		{
		    Popup::Message (msg);
		}
	    }
	    else
	    {
		y2warning("Invalid index '%1' for card: %2", card_id, uniq);
	    }
	}
	else
	{
	    ret = ui;
	}
    } while (!contains([`back, `abort, `next, `add, `edit, `delete, `mixer],ret));

    Wizard::RestoreNextButton();
    if (!Mode::installation()) Wizard::RestoreBackButton();

    return $[ "ui": ret ];
}



// ===== MAIN =====

/**
 * just calls ComplexDialog
 * @return map passed from ComplexDialog
 */
define map sound_complex() ``{

    list to_delete	= [];
    boolean config_mode = false;

    return HardwareDialog();
//    return ComplexDialog ();
}

}//EOF
