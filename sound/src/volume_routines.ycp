/**
 * File:
 *   volume_routines.ycp
 *
 * Module:
 *   Sound
 *
 * Summary:
 *   Routines for sound card volume settings
 *
 * Authors:
 *	Dan Vesely <dan@suse.cz>
 *	Dan Meszaros <dmeszar@suse.cz>
 *	Jiri Suchomel <jsuchome@suse.cz>
 *
 */

{
    import "Arch";
    import "Sound";
    import "Directory";
    import "Mode";
    import "Popup";

    textdomain "sound";

    /**
     * sets volume in percents (0..100) for given card and card_id
     * @param group channel
     * @param cardid card id
     * @param value volume 0-100
     * @return boolean success/failure
     */
    define boolean setVolume (string group, integer cardid, integer value) ``{

	y2debug("setVolume(group: %1, cardid: %2, value: %3", group, cardid, value);

	if (!Sound::use_alsa)
	{
	    if (Arch::sparc ())
	    {
		string cmd =
		 sformat("/usr/bin/aumix -d /dev/mixer%1 -w %2", cardid, value);
		SCR::Execute(.target.bash, cmd, $[]);
	    }
	    else
	    {
		string p =
		    sformat(".audio.oss.cards.%1.channels.%2", cardid, group);
		SCR::Write(topath(p), value);
	    }
	    return true;
	}

	// rest is for ALSA
	// In Mode::autoinst(), we need to update volume_settings from
	// UpdateCardsToTargetSystem functions; volume will be saved later
	// in set_vol_settings ().
	if (!Mode::config() && !Mode::autoinst())
	{
	    string p = sformat(".audio.alsa.cards.%1.channels.%2.volume",
		cardid, group);
	    return SCR::Write(topath(p), value);
	}
	else
	{
	    list<list> tmp = Sound::volume_settings[cardid]:[];

	    boolean found = false;
	    list<list> updated_channels = [];
	    foreach(list ch, tmp,
		{
		    list new_ch = ch;

		    if (new_ch[0]:"" == group)
		    {
			new_ch[1] = value;
			found = true;
		    }

		    updated_channels = add(updated_channels, new_ch);
		}
	    );

	    if (found)
	    {
		// the channel has been found, use the updates list
		tmp = updated_channels;
	    }
	    else
	    {
		// the channel has not been found, add it to the list
		tmp = add(tmp, [ group, value, false ]);
	    }

            Sound::volume_settings[cardid] = tmp;

	    return true;
	}
    }

    /**
     * stores the volume to file. stored volume will be restored after reboot
     * (ALSA only)
     * @param card_id card id
     * @return boolean success/failure
     */
    define boolean storeVolume(integer card_id) ``{
	if (card_id == -1)
	{
	    SCR::Execute(.audio.alsa.store, 0, 0);
	}
	string p = sformat(".audio.alsa.cards.%1.store", card_id);

	return (boolean) SCR::Execute(topath(p), 0, 0);
    }


    /**
     * plays test sound to card #card_id
     * @param card_id card id
     * @return string with error message. empty on success
     */
    define string PlayTest (integer card_id) ``{

	string fname = "/usr/share/sounds/alsa/test.wav";
	if (!Sound::use_alsa)
	{
	    fname="/usr/share/sounds/test.mp3";
	}
	if (SCR::Read(.target.size, fname) == -1)
	{
	    // popup message: test audio file was not found
	    return sformat (_("Cannot find file:
%1
(test audio file)"),
		fname);
        }

	string command = (!Sound::use_alsa) ?
	    sformat("/usr/bin/mpg123 -a /dev/dsp%1 %2", card_id, fname)
	    // unset ALSA_CONFIG_PATH (bnc#440981)
	    : sformat("ALSA_CONFIG_PATH= /usr/bin/aplay -q -N -D default:%1 %2 > /dev/null 2>&1", card_id, fname);

	y2milestone("Executing: %1", command);

        SCR::Execute(.target.bash_background, command);

        return "";
    }


    /**
     * sound_start_tmp starts alsa using temporary modules.conf
     * @param restore true - call alsactl restore, false - don't
     * @return void
     */
    define boolean sound_start_tmp(boolean restore) ``{
	boolean ret = true;

	// get the list of commands needed for start
	list cmds = Sound::CreateModprobeCommands();
	y2milestone("modprobe commands: %1", cmds);

	string snd = sformat ("/sbin/modprobe snd cards_limit=%1 major=116",
	    size (Sound::modules_conf));

	if (!Sound::use_alsa)
	{
	    snd = sformat("/sbin/modprobe snd snd_cards_limit=%1 snd_major=116", size(Sound::modules_conf));
	    //FIXME parameter names for OSS?
	}

	// start 'snd' module first
	cmds = flatten ([[snd], cmds]);
	maplist(string cmd, (list<string>) cmds, ``{
	    map res = (map) SCR::Execute(.target.bash_output, cmd, $[]);
	    if (res["stderr"]:"" != "")
	    {
                y2error("/sbin/modprobe error output: \n" + res["stderr"]:"");
		ret = false;
	    }
	});

	return ret;
    }

    /**
     * removes all sound modules from kernel
     * @return void
     */
    define void sound_stop() ``{

	if (Sound::use_alsa)
	{
	    string cmd = Directory::bindir + "/alsadrivers unload";
	    y2milestone("Executing: %1", cmd);
	    SCR::Execute(.target.bash, cmd);

	    boolean aoa_used = false;
	    foreach(map card, Sound::modules_conf,
		{
		    if (card["module"]:"" == "snd-aoa")
		    {
			aoa_used = true;
		    }
		}
	    );

	    if (aoa_used)
	    {
		// unload the extra module
		y2milestone("Unloading snd-aoa-i2sbus driver");
		SCR::Execute(.target.bash, "/sbin/rmmod snd-aoa-i2sbus");
		SCR::Execute(.target.bash, "/sbin/rmmod snd-aoa-fabric-layout");
	    }
	}
	else
	{
	    list mods = SCR::Dir(.modinfo.kernel.sound.oss);
	    mods = add(mods, "emu10k1");
	    mods = add(mods, "cs4281");
	    map modules = (map) SCR::Read(.proc.modules);
	    foreach(string mod, (list<string>) mods, ``{
		if(haskey(modules, mod))
		{
		    SCR::Execute(.target.bash,sformat("/sbin/rmmod -r %1",mod));
		}
	    });
	}
    }

    boolean GlobExists(string glob)
    {
	map out = (map)SCR::Execute(.target.bash_output, sformat("echo -n %1", glob));
	y2debug("output: %1", out);

	return out["stdout"]:"" != glob;
    }

    /**
     * stops all programs using sound devices
     * @return boolean true if nothing's using sound, false otherwise
     */
    define boolean stop_programs() ``{
	if (Mode::config() || Mode::autoinst())
	{
	    return true;
	}

	// list of files to check, * must be present!
	list<string> audio_files = ["/dev/dsp*", "/dev/audio*", "/dev/mixer*", "/dev/midi*", "/dev/mixer*"];

	audio_files = filter(string file, audio_files, {return GlobExists(file);});
	y2milestone("Checking audio files: %1", audio_files);

	if (size(audio_files) == 0)
	{
	    y2milestone("No audio device file found, skipping fuser call");
	    return true;
	}

	string fuser_options = mergestring(audio_files, " ");
	y2milestone("fuser options: %1", fuser_options);

	integer fuser = (integer) SCR::Execute (.target.bash, "/bin/fuser " + fuser_options, $[]);

	if (fuser == 0)
        {
	    string msg		= Sound::STRINGS["WhichDialogMsg"]:"";
            boolean terminate	= Sound::use_ui ? Popup::YesNo (msg) : true;
            if (terminate)
            {
		SCR::Execute (.target.bash, "/bin/fuser -k " + fuser_options, $[]);
            }
            else
            {
		return false;
            }
        }
	return true;
    }

}//EOF
