/**
 * File:	include/sound/wizards.ycp
 * Package:	Configuration of sound cards
 * Summary:	Wizards definitions
 * Authors:	Dan Vesely <dan@suse.cz>,
 *		Dan Meszaros <dmeszar@suse.cz>,
 *		Jiri Suchomel <jsuchome@suse.cz>
 *
 */

{

    textdomain "sound";

    import "Mode";
    import "Popup";
    import "Sequencer";
    import "Wizard";
    import "Sound";
    import "Joystick";

    include "sound/card_wizard.ycp";
    include "sound/read_routines.ycp";
    include "sound/routines.ycp";
    include "sound/volume_routines.ycp";
    include "sound/write_routines.ycp";
    include "sound/volume.ycp";
    include "sound/options.ycp";
    include "sound/complex.ycp";
    include "sound/manual.ycp";


    boolean was_complex = false;

    /**
     * dialog for manual card selection
     * @return symbol next dialog
     */
    define symbol _snd_manual() ``{

	map res		= sound_manual();
	symbol ui	= res["ui"]:`abort;

	if (ui == `next)
	{
	    Sound::save_entry		= update_manual_card (res);
	    Sound::card_id	= -1;
	}
	if (ui == `back)
	{
	    Sound::save_entry	= $[];
	}
	return ui;
    }

    /**
     * sound card deletion
     * @return symbol next dialog
     */
    define symbol _snd_delete() ``{
	if (!Sound::use_ui ||
	    // popup question
	    Popup::YesNo(_("Do you really want to delete this entry?")))
	{
	    if (!stop_programs())
            {
                return `next;
            }

	    // remove joystick settings
	    if (Sound::card_id<4 && Joystick::joystick[Sound::card_id]:nil!=nil)
	    {
		Joystick::joystick = remove (Joystick::joystick,Sound::card_id);
		Joystick::joystick[3] = $[];
	    }

            // we have to remember volume/mute settings because after a
	    // card removal everything is muted and set to 0.
            list<list<list> > vol_settings = get_vol_settings();
	    if (Mode::config())
		vol_settings	= Sound::volume_settings;

	    // remember info about removed card
	    map removed_card = Sound::modules_conf[Sound::card_id]:$[];
	    map removed_info = $[];

	    // get hwcfg file from list of configured cards
	    foreach(map c, Sound::modules_conf, {
		    if (c["unique_key"]:"" == removed_card["unique_key"]:"unknown")
		    {
			removed_info["hwcfg"] = c["hwcfg"]:"";
		    }
		}
	    );

            Sound::modules_conf	= remove (Sound::modules_conf, Sound::card_id);
	    Sound::modules_conf	    = recalc_save_entries(Sound::modules_conf);

	    y2milestone("removed_card: %1", removed_card);

	    if (size(removed_card) > 0)
	    {
		removed_info["bus_hwcfg"] = removed_card["bus_hwcfg"]:"";
		removed_info["sysfs_bus_id"] = removed_card["sysfs_bus_id"]:"";
		removed_info["unique_key"] = removed_card["unique_key"]:"";
		removed_info["module"] = removed_card["module"]:"";

		if (!contains(Sound::removed_info, removed_info))
		{
		    Sound::removed_info = add(Sound::removed_info, removed_info);
		    y2milestone("added removed card info: %1", removed_info);
		}
	    }

	    if (vol_settings[Sound::card_id]:nil != nil)
	    {
		vol_settings    = remove (vol_settings, Sound::card_id);
		// we have to move old entry in global list:
		if (!Mode::config())
		    Sound::volume_settings = add (vol_settings,
			Sound::volume_settings[Sound::card_id]:[]);
		else
		    Sound::volume_settings = eval (vol_settings);
	    }

	    if (!Mode::config())
	    {
		sound_stop();
		sound_start_tmp(true);
		set_vol_settings(vol_settings);
		// now we have to update the unconfigured cards list
		Sound::UpdateUnconfiguredCards();
	    }
	}
	return `next;
    }

    /**
     * configure selected card
     * @return symbol next dialog
     */
    define symbol _snd_config() ``{
	if (Sound::card_id >= 0)
	{
	    Sound::save_entry = Sound::unconfigured_cards [Sound::card_id]:$[];
	}
	map res = OneCardWizard (Sound::save_entry, size(Sound::modules_conf),
	    15, false, Sound::modules_conf);

	symbol ui	= res["ui"]:`back;
        if (ui == `next)
        {
	    // copy card_entry from unconfigured to configured list
            Sound::modules_conf = add(Sound::modules_conf, res["return"]:$[]);
	    if (Sound::card_id >= 0)
	    {
		// if this this card was autodetedted, remove
		// card we've just configured from unconfigured card list.
		Sound::unconfigured_cards = remove (Sound::unconfigured_cards,
		    Sound::card_id);
	    }
	    if (size(Sound::unconfigured_cards) == 0)
	    {
		// no other detected && unconfigured cards remained
		return `detail;
	    }
        }
	return ui;
    }

    /**
     * complex dialog
     * @return symbol next dialog
     */
    define symbol _snd_complex() ``{
	was_complex = true;
	map res	    = sound_complex();
        return (symbol) (res["ui"]:nil);
    }


/**
 * Main workflow of sound configuration (without read and write)
 * @return sequence result
 */
define symbol MainSequence() ``{

    map m_aliases = $[
	    "config"	: ``(_snd_config()),
	    "manual"	: ``(_snd_manual()),
	    "complex"	: ``(_snd_complex()),
	    "delete"	: ``(_snd_delete()),
	    "edit"	: [``(Edit()), true],
	    "editconf"	: ``(EditConfigured()),
	    "mixer"	: ``(Mixer()),
	];

    map m_sequence = $[
	    "ws_start"	: "complex",
	    "config"	:
		$[
		    `next	    :	"complex",
		    `detail	    :	"complex",
		    `abort	    :   `abort
		],
	    "manual"	:
		$[
		    `next	    :	"config",
		    `abort	    :	`abort
		],

	    "complex"	:
		$[
		    `next	    :	`finish,
		    `abort	    :	`abort,
		    `add	    :	"manual",
		    `edit	    :   "edit",
		    `delete	    :	"delete",
		    `mixer	    :	"mixer"
		],
	    "mixer"	:
		$[
		    `next	    :	"complex",
		    `abort	    :	`abort
		],
	    "edit"	:
		$[
		    `edit_new	    :	"config",
		    `edit_conf	    :	"editconf",
		    `not_found	    :	"complex"
		],
	    "editconf"	:
		$[
		    `next	    :	"complex",
		    `abort	    :	`abort
		],
	    "delete"	:
		$[
		    `next	    :	"complex"
		],
    ];

    return Sequencer::Run (m_aliases, m_sequence);
}

// TODO create AutoSequence (used also for installation?)
// - call of MainSequence with some work before and after

/**
 * Whole configuration of sound
 * @return sequence result
 */
define symbol SoundSequence () ``{

    Sound::use_ui = true;

    Wizard::CreateDialog();
    Wizard::SetDesktopTitleAndIcon("sound");

    if (!Mode::config() && !Sound::installation)
    {
	if (!Sound::Read(true))
	    return `abort;
	block<boolean> abort = ``{ return false;};
	Joystick::Read(abort);
	PulseAudio::Read();
	Sound::StoreSettings();
    }

    if (Sound::installation)
    {
	Sound::StoreSettings();
	if (Sound::detected_cards == [] && Sound::modules_conf == [])
	    Sound::DetectOldCards();
	Sound::UpdateUnconfiguredCards();
	sound_stop();
	sound_start_tmp(true);
	// init mixer for all soundcards
	integer index = 0;
	maplist (map card, Sound::modules_conf, ``{
	    Sound::InitMixer(index, card["module"]:"");
	    index = index + 1;
	});
    }

    integer n_cards	= 0;
    integer all_cards_num = size(Sound::unconfigured_cards);

    nm256_opl3sa2_warn (flatten(
	add([Sound::modules_conf], Sound::unconfigured_cards)));

    if (size(flatten(add([Sound::modules_conf], Sound::unconfigured_cards)))==1)
    {
	boolean nm256out = nm256hack (Sound::unconfigured_cards[0,"module"]:"");
	y2debug("continue configuring: %1", nm256out);
	if (!nm256out)
	{
	    UI::CloseDialog();
	    return `back;
	}
    }

    symbol ui = MainSequence();

    if (ui == `back || ui == `abort)
    {
	if (Sound::installation)
	{
	    Sound::RestoreSettings();
	}
	UI::CloseDialog();
	return `back;
    }

    n_cards = size (Sound::modules_conf);

    map save_map = $[];

    if (Sound::installation)
    {
	if (ui != `finish)
	{
	    Sound::RestoreSettings();
	}
	else
	    ui = `next; // in installation mode, `finish is end of installation
    }

    if (ui == `finish && !Mode::config())
    {
	if ((!Sound::installation) && ( Sound::Changed() || Sound::GetModified() || Joystick::Changed()
	    || (!Sound::AllRequiredPackagesInstalled())))
	{
	    Sound::Write ();
	}
	else
	{
	    y2milestone("Not writing the configuration");
	}

	if (PulseAudio::Modified())
	{
	    y2milestone("Writing changed PulseAudio configuration...");
	    PulseAudio::Write();
	}
    }

    UI::CloseDialog ();
    return ui;
}

/* EOF */
}
